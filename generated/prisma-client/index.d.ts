// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  appointment: (where?: appointmentWhereInput) => Promise<boolean>;
  day: (where?: dayWhereInput) => Promise<boolean>;
  department: (where?: departmentWhereInput) => Promise<boolean>;
  establishment: (where?: establishmentWhereInput) => Promise<boolean>;
  hour: (where?: hourWhereInput) => Promise<boolean>;
  report: (where?: reportWhereInput) => Promise<boolean>;
  review: (where?: reviewWhereInput) => Promise<boolean>;
  service: (where?: serviceWhereInput) => Promise<boolean>;
  typeofshift: (where?: typeofshiftWhereInput) => Promise<boolean>;
  user: (where?: userWhereInput) => Promise<boolean>;
  userestablishment: (where?: userestablishmentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  appointment: (
    where: appointmentWhereUniqueInput
  ) => appointmentNullablePromise;
  appointments: (args?: {
    where?: appointmentWhereInput;
    orderBy?: appointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<appointment>;
  appointmentsConnection: (args?: {
    where?: appointmentWhereInput;
    orderBy?: appointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => appointmentConnectionPromise;
  day: (where: dayWhereUniqueInput) => dayNullablePromise;
  days: (args?: {
    where?: dayWhereInput;
    orderBy?: dayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<day>;
  daysConnection: (args?: {
    where?: dayWhereInput;
    orderBy?: dayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => dayConnectionPromise;
  department: (where: departmentWhereUniqueInput) => departmentNullablePromise;
  departments: (args?: {
    where?: departmentWhereInput;
    orderBy?: departmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<department>;
  departmentsConnection: (args?: {
    where?: departmentWhereInput;
    orderBy?: departmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => departmentConnectionPromise;
  establishment: (
    where: establishmentWhereUniqueInput
  ) => establishmentNullablePromise;
  establishments: (args?: {
    where?: establishmentWhereInput;
    orderBy?: establishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<establishment>;
  establishmentsConnection: (args?: {
    where?: establishmentWhereInput;
    orderBy?: establishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => establishmentConnectionPromise;
  hour: (where: hourWhereUniqueInput) => hourNullablePromise;
  hours: (args?: {
    where?: hourWhereInput;
    orderBy?: hourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<hour>;
  hoursConnection: (args?: {
    where?: hourWhereInput;
    orderBy?: hourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => hourConnectionPromise;
  report: (where: reportWhereUniqueInput) => reportNullablePromise;
  reports: (args?: {
    where?: reportWhereInput;
    orderBy?: reportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<report>;
  reportsConnection: (args?: {
    where?: reportWhereInput;
    orderBy?: reportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => reportConnectionPromise;
  review: (where: reviewWhereUniqueInput) => reviewNullablePromise;
  reviews: (args?: {
    where?: reviewWhereInput;
    orderBy?: reviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<review>;
  reviewsConnection: (args?: {
    where?: reviewWhereInput;
    orderBy?: reviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => reviewConnectionPromise;
  service: (where: serviceWhereUniqueInput) => serviceNullablePromise;
  services: (args?: {
    where?: serviceWhereInput;
    orderBy?: serviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<service>;
  servicesConnection: (args?: {
    where?: serviceWhereInput;
    orderBy?: serviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => serviceConnectionPromise;
  typeofshift: (
    where: typeofshiftWhereUniqueInput
  ) => typeofshiftNullablePromise;
  typeofshifts: (args?: {
    where?: typeofshiftWhereInput;
    orderBy?: typeofshiftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<typeofshift>;
  typeofshiftsConnection: (args?: {
    where?: typeofshiftWhereInput;
    orderBy?: typeofshiftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => typeofshiftConnectionPromise;
  user: (where: userWhereUniqueInput) => userNullablePromise;
  users: (args?: {
    where?: userWhereInput;
    orderBy?: userOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<user>;
  usersConnection: (args?: {
    where?: userWhereInput;
    orderBy?: userOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => userConnectionPromise;
  userestablishment: (
    where: userestablishmentWhereUniqueInput
  ) => userestablishmentNullablePromise;
  userestablishments: (args?: {
    where?: userestablishmentWhereInput;
    orderBy?: userestablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<userestablishment>;
  userestablishmentsConnection: (args?: {
    where?: userestablishmentWhereInput;
    orderBy?: userestablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => userestablishmentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createappointment: (data: appointmentCreateInput) => appointmentPromise;
  updateappointment: (args: {
    data: appointmentUpdateInput;
    where: appointmentWhereUniqueInput;
  }) => appointmentPromise;
  updateManyappointments: (args: {
    data: appointmentUpdateManyMutationInput;
    where?: appointmentWhereInput;
  }) => BatchPayloadPromise;
  upsertappointment: (args: {
    where: appointmentWhereUniqueInput;
    create: appointmentCreateInput;
    update: appointmentUpdateInput;
  }) => appointmentPromise;
  deleteappointment: (where: appointmentWhereUniqueInput) => appointmentPromise;
  deleteManyappointments: (
    where?: appointmentWhereInput
  ) => BatchPayloadPromise;
  createday: (data: dayCreateInput) => dayPromise;
  updateday: (args: {
    data: dayUpdateInput;
    where: dayWhereUniqueInput;
  }) => dayPromise;
  updateManydays: (args: {
    data: dayUpdateManyMutationInput;
    where?: dayWhereInput;
  }) => BatchPayloadPromise;
  upsertday: (args: {
    where: dayWhereUniqueInput;
    create: dayCreateInput;
    update: dayUpdateInput;
  }) => dayPromise;
  deleteday: (where: dayWhereUniqueInput) => dayPromise;
  deleteManydays: (where?: dayWhereInput) => BatchPayloadPromise;
  createdepartment: (data: departmentCreateInput) => departmentPromise;
  updatedepartment: (args: {
    data: departmentUpdateInput;
    where: departmentWhereUniqueInput;
  }) => departmentPromise;
  updateManydepartments: (args: {
    data: departmentUpdateManyMutationInput;
    where?: departmentWhereInput;
  }) => BatchPayloadPromise;
  upsertdepartment: (args: {
    where: departmentWhereUniqueInput;
    create: departmentCreateInput;
    update: departmentUpdateInput;
  }) => departmentPromise;
  deletedepartment: (where: departmentWhereUniqueInput) => departmentPromise;
  deleteManydepartments: (where?: departmentWhereInput) => BatchPayloadPromise;
  createestablishment: (data: establishmentCreateInput) => establishmentPromise;
  updateestablishment: (args: {
    data: establishmentUpdateInput;
    where: establishmentWhereUniqueInput;
  }) => establishmentPromise;
  updateManyestablishments: (args: {
    data: establishmentUpdateManyMutationInput;
    where?: establishmentWhereInput;
  }) => BatchPayloadPromise;
  upsertestablishment: (args: {
    where: establishmentWhereUniqueInput;
    create: establishmentCreateInput;
    update: establishmentUpdateInput;
  }) => establishmentPromise;
  deleteestablishment: (
    where: establishmentWhereUniqueInput
  ) => establishmentPromise;
  deleteManyestablishments: (
    where?: establishmentWhereInput
  ) => BatchPayloadPromise;
  createhour: (data: hourCreateInput) => hourPromise;
  updatehour: (args: {
    data: hourUpdateInput;
    where: hourWhereUniqueInput;
  }) => hourPromise;
  updateManyhours: (args: {
    data: hourUpdateManyMutationInput;
    where?: hourWhereInput;
  }) => BatchPayloadPromise;
  upserthour: (args: {
    where: hourWhereUniqueInput;
    create: hourCreateInput;
    update: hourUpdateInput;
  }) => hourPromise;
  deletehour: (where: hourWhereUniqueInput) => hourPromise;
  deleteManyhours: (where?: hourWhereInput) => BatchPayloadPromise;
  createreport: (data: reportCreateInput) => reportPromise;
  updatereport: (args: {
    data: reportUpdateInput;
    where: reportWhereUniqueInput;
  }) => reportPromise;
  updateManyreports: (args: {
    data: reportUpdateManyMutationInput;
    where?: reportWhereInput;
  }) => BatchPayloadPromise;
  upsertreport: (args: {
    where: reportWhereUniqueInput;
    create: reportCreateInput;
    update: reportUpdateInput;
  }) => reportPromise;
  deletereport: (where: reportWhereUniqueInput) => reportPromise;
  deleteManyreports: (where?: reportWhereInput) => BatchPayloadPromise;
  createreview: (data: reviewCreateInput) => reviewPromise;
  updatereview: (args: {
    data: reviewUpdateInput;
    where: reviewWhereUniqueInput;
  }) => reviewPromise;
  updateManyreviews: (args: {
    data: reviewUpdateManyMutationInput;
    where?: reviewWhereInput;
  }) => BatchPayloadPromise;
  upsertreview: (args: {
    where: reviewWhereUniqueInput;
    create: reviewCreateInput;
    update: reviewUpdateInput;
  }) => reviewPromise;
  deletereview: (where: reviewWhereUniqueInput) => reviewPromise;
  deleteManyreviews: (where?: reviewWhereInput) => BatchPayloadPromise;
  createservice: (data: serviceCreateInput) => servicePromise;
  updateservice: (args: {
    data: serviceUpdateInput;
    where: serviceWhereUniqueInput;
  }) => servicePromise;
  updateManyservices: (args: {
    data: serviceUpdateManyMutationInput;
    where?: serviceWhereInput;
  }) => BatchPayloadPromise;
  upsertservice: (args: {
    where: serviceWhereUniqueInput;
    create: serviceCreateInput;
    update: serviceUpdateInput;
  }) => servicePromise;
  deleteservice: (where: serviceWhereUniqueInput) => servicePromise;
  deleteManyservices: (where?: serviceWhereInput) => BatchPayloadPromise;
  createtypeofshift: (data: typeofshiftCreateInput) => typeofshiftPromise;
  updatetypeofshift: (args: {
    data: typeofshiftUpdateInput;
    where: typeofshiftWhereUniqueInput;
  }) => typeofshiftPromise;
  updateManytypeofshifts: (args: {
    data: typeofshiftUpdateManyMutationInput;
    where?: typeofshiftWhereInput;
  }) => BatchPayloadPromise;
  upserttypeofshift: (args: {
    where: typeofshiftWhereUniqueInput;
    create: typeofshiftCreateInput;
    update: typeofshiftUpdateInput;
  }) => typeofshiftPromise;
  deletetypeofshift: (where: typeofshiftWhereUniqueInput) => typeofshiftPromise;
  deleteManytypeofshifts: (
    where?: typeofshiftWhereInput
  ) => BatchPayloadPromise;
  createuser: (data: userCreateInput) => userPromise;
  updateuser: (args: {
    data: userUpdateInput;
    where: userWhereUniqueInput;
  }) => userPromise;
  updateManyusers: (args: {
    data: userUpdateManyMutationInput;
    where?: userWhereInput;
  }) => BatchPayloadPromise;
  upsertuser: (args: {
    where: userWhereUniqueInput;
    create: userCreateInput;
    update: userUpdateInput;
  }) => userPromise;
  deleteuser: (where: userWhereUniqueInput) => userPromise;
  deleteManyusers: (where?: userWhereInput) => BatchPayloadPromise;
  createuserestablishment: (
    data: userestablishmentCreateInput
  ) => userestablishmentPromise;
  updateuserestablishment: (args: {
    data: userestablishmentUpdateInput;
    where: userestablishmentWhereUniqueInput;
  }) => userestablishmentPromise;
  updateManyuserestablishments: (args: {
    data: userestablishmentUpdateManyMutationInput;
    where?: userestablishmentWhereInput;
  }) => BatchPayloadPromise;
  upsertuserestablishment: (args: {
    where: userestablishmentWhereUniqueInput;
    create: userestablishmentCreateInput;
    update: userestablishmentUpdateInput;
  }) => userestablishmentPromise;
  deleteuserestablishment: (
    where: userestablishmentWhereUniqueInput
  ) => userestablishmentPromise;
  deleteManyuserestablishments: (
    where?: userestablishmentWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  appointment: (
    where?: appointmentSubscriptionWhereInput
  ) => appointmentSubscriptionPayloadSubscription;
  day: (
    where?: daySubscriptionWhereInput
  ) => daySubscriptionPayloadSubscription;
  department: (
    where?: departmentSubscriptionWhereInput
  ) => departmentSubscriptionPayloadSubscription;
  establishment: (
    where?: establishmentSubscriptionWhereInput
  ) => establishmentSubscriptionPayloadSubscription;
  hour: (
    where?: hourSubscriptionWhereInput
  ) => hourSubscriptionPayloadSubscription;
  report: (
    where?: reportSubscriptionWhereInput
  ) => reportSubscriptionPayloadSubscription;
  review: (
    where?: reviewSubscriptionWhereInput
  ) => reviewSubscriptionPayloadSubscription;
  service: (
    where?: serviceSubscriptionWhereInput
  ) => serviceSubscriptionPayloadSubscription;
  typeofshift: (
    where?: typeofshiftSubscriptionWhereInput
  ) => typeofshiftSubscriptionPayloadSubscription;
  user: (
    where?: userSubscriptionWhereInput
  ) => userSubscriptionPayloadSubscription;
  userestablishment: (
    where?: userestablishmentSubscriptionWhereInput
  ) => userestablishmentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type appointmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "endHour_ASC"
  | "endHour_DESC"
  | "startHour_ASC"
  | "startHour_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type dayOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type departmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "departmentCode_ASC"
  | "departmentCode_DESC"
  | "name_ASC"
  | "name_DESC";

export type establishmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "address_ASC"
  | "address_DESC"
  | "addressComplement_ASC"
  | "addressComplement_DESC"
  | "city_ASC"
  | "city_DESC"
  | "commercialName_ASC"
  | "commercialName_DESC"
  | "contactEmail_ASC"
  | "contactEmail_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "illustration_ASC"
  | "illustration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "siret_ASC"
  | "siret_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC";

export type hourOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "endHour_ASC"
  | "endHour_DESC"
  | "nbBarber_ASC"
  | "nbBarber_DESC"
  | "startHour_ASC"
  | "startHour_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type reportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type reviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "mark_ASC"
  | "mark_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type serviceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "illustration_ASC"
  | "illustration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type typeofshiftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type userOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "birthdate_ASC"
  | "birthdate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "roles_ASC"
  | "roles_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type userestablishmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "validated_ASC"
  | "validated_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type appointmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface appointmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<appointmentWhereInput[] | appointmentWhereInput>;
  OR?: Maybe<appointmentWhereInput[] | appointmentWhereInput>;
  NOT?: Maybe<appointmentWhereInput[] | appointmentWhereInput>;
}

export type dayWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface dayWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<dayWhereInput[] | dayWhereInput>;
  OR?: Maybe<dayWhereInput[] | dayWhereInput>;
  NOT?: Maybe<dayWhereInput[] | dayWhereInput>;
}

export type departmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface departmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  departmentCode_not?: Maybe<Int>;
  departmentCode_in?: Maybe<Int[] | Int>;
  departmentCode_not_in?: Maybe<Int[] | Int>;
  departmentCode_lt?: Maybe<Int>;
  departmentCode_lte?: Maybe<Int>;
  departmentCode_gt?: Maybe<Int>;
  departmentCode_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<departmentWhereInput[] | departmentWhereInput>;
  OR?: Maybe<departmentWhereInput[] | departmentWhereInput>;
  NOT?: Maybe<departmentWhereInput[] | departmentWhereInput>;
}

export type establishmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface establishmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  addressComplement?: Maybe<String>;
  addressComplement_not?: Maybe<String>;
  addressComplement_in?: Maybe<String[] | String>;
  addressComplement_not_in?: Maybe<String[] | String>;
  addressComplement_lt?: Maybe<String>;
  addressComplement_lte?: Maybe<String>;
  addressComplement_gt?: Maybe<String>;
  addressComplement_gte?: Maybe<String>;
  addressComplement_contains?: Maybe<String>;
  addressComplement_not_contains?: Maybe<String>;
  addressComplement_starts_with?: Maybe<String>;
  addressComplement_not_starts_with?: Maybe<String>;
  addressComplement_ends_with?: Maybe<String>;
  addressComplement_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  commercialName?: Maybe<String>;
  commercialName_not?: Maybe<String>;
  commercialName_in?: Maybe<String[] | String>;
  commercialName_not_in?: Maybe<String[] | String>;
  commercialName_lt?: Maybe<String>;
  commercialName_lte?: Maybe<String>;
  commercialName_gt?: Maybe<String>;
  commercialName_gte?: Maybe<String>;
  commercialName_contains?: Maybe<String>;
  commercialName_not_contains?: Maybe<String>;
  commercialName_starts_with?: Maybe<String>;
  commercialName_not_starts_with?: Maybe<String>;
  commercialName_ends_with?: Maybe<String>;
  commercialName_not_ends_with?: Maybe<String>;
  contactEmail?: Maybe<String>;
  contactEmail_not?: Maybe<String>;
  contactEmail_in?: Maybe<String[] | String>;
  contactEmail_not_in?: Maybe<String[] | String>;
  contactEmail_lt?: Maybe<String>;
  contactEmail_lte?: Maybe<String>;
  contactEmail_gt?: Maybe<String>;
  contactEmail_gte?: Maybe<String>;
  contactEmail_contains?: Maybe<String>;
  contactEmail_not_contains?: Maybe<String>;
  contactEmail_starts_with?: Maybe<String>;
  contactEmail_not_starts_with?: Maybe<String>;
  contactEmail_ends_with?: Maybe<String>;
  contactEmail_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  siret?: Maybe<String>;
  siret_not?: Maybe<String>;
  siret_in?: Maybe<String[] | String>;
  siret_not_in?: Maybe<String[] | String>;
  siret_lt?: Maybe<String>;
  siret_lte?: Maybe<String>;
  siret_gt?: Maybe<String>;
  siret_gte?: Maybe<String>;
  siret_contains?: Maybe<String>;
  siret_not_contains?: Maybe<String>;
  siret_starts_with?: Maybe<String>;
  siret_not_starts_with?: Maybe<String>;
  siret_ends_with?: Maybe<String>;
  siret_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<establishmentWhereInput[] | establishmentWhereInput>;
  OR?: Maybe<establishmentWhereInput[] | establishmentWhereInput>;
  NOT?: Maybe<establishmentWhereInput[] | establishmentWhereInput>;
}

export type hourWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface hourWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  nbBarber_not?: Maybe<Int>;
  nbBarber_in?: Maybe<Int[] | Int>;
  nbBarber_not_in?: Maybe<Int[] | Int>;
  nbBarber_lt?: Maybe<Int>;
  nbBarber_lte?: Maybe<Int>;
  nbBarber_gt?: Maybe<Int>;
  nbBarber_gte?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<hourWhereInput[] | hourWhereInput>;
  OR?: Maybe<hourWhereInput[] | hourWhereInput>;
  NOT?: Maybe<hourWhereInput[] | hourWhereInput>;
}

export type reportWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface reportWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<reportWhereInput[] | reportWhereInput>;
  OR?: Maybe<reportWhereInput[] | reportWhereInput>;
  NOT?: Maybe<reportWhereInput[] | reportWhereInput>;
}

export type reviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface reviewWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
  mark_not?: Maybe<Int>;
  mark_in?: Maybe<Int[] | Int>;
  mark_not_in?: Maybe<Int[] | Int>;
  mark_lt?: Maybe<Int>;
  mark_lte?: Maybe<Int>;
  mark_gt?: Maybe<Int>;
  mark_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<reviewWhereInput[] | reviewWhereInput>;
  OR?: Maybe<reviewWhereInput[] | reviewWhereInput>;
  NOT?: Maybe<reviewWhereInput[] | reviewWhereInput>;
}

export type serviceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface serviceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<serviceWhereInput[] | serviceWhereInput>;
  OR?: Maybe<serviceWhereInput[] | serviceWhereInput>;
  NOT?: Maybe<serviceWhereInput[] | serviceWhereInput>;
}

export type typeofshiftWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface typeofshiftWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<typeofshiftWhereInput[] | typeofshiftWhereInput>;
  OR?: Maybe<typeofshiftWhereInput[] | typeofshiftWhereInput>;
  NOT?: Maybe<typeofshiftWhereInput[] | typeofshiftWhereInput>;
}

export type userWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface userWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  birthdate_not?: Maybe<DateTimeInput>;
  birthdate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_lt?: Maybe<DateTimeInput>;
  birthdate_lte?: Maybe<DateTimeInput>;
  birthdate_gt?: Maybe<DateTimeInput>;
  birthdate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<userWhereInput[] | userWhereInput>;
  OR?: Maybe<userWhereInput[] | userWhereInput>;
  NOT?: Maybe<userWhereInput[] | userWhereInput>;
}

export type userestablishmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface userestablishmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
  validated_not?: Maybe<Boolean>;
  AND?: Maybe<userestablishmentWhereInput[] | userestablishmentWhereInput>;
  OR?: Maybe<userestablishmentWhereInput[] | userestablishmentWhereInput>;
  NOT?: Maybe<userestablishmentWhereInput[] | userestablishmentWhereInput>;
}

export interface appointmentCreateInput {
  id?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface appointmentUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface appointmentUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface dayCreateInput {
  id?: Maybe<Int>;
  name: String;
}

export interface dayUpdateInput {
  name?: Maybe<String>;
}

export interface dayUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface departmentCreateInput {
  id?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface departmentUpdateInput {
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface departmentUpdateManyMutationInput {
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface establishmentCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface establishmentUpdateInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface establishmentUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface hourCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface hourUpdateInput {
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface hourUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface reportCreateInput {
  id?: Maybe<Int>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface reportUpdateInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface reportUpdateManyMutationInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface reviewCreateInput {
  id?: Maybe<Int>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface reviewUpdateInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface reviewUpdateManyMutationInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface serviceCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
}

export interface serviceUpdateInput {
  active?: Maybe<Boolean>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
}

export interface serviceUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
}

export interface typeofshiftCreateInput {
  id?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface typeofshiftUpdateInput {
  name?: Maybe<String>;
}

export interface typeofshiftUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface userCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email: String;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  roles: Json;
}

export interface userUpdateInput {
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  roles?: Maybe<Json>;
}

export interface userUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  roles?: Maybe<Json>;
}

export interface userestablishmentCreateInput {
  id?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
}

export interface userestablishmentUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
}

export interface userestablishmentUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
}

export interface appointmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<appointmentWhereInput>;
  AND?: Maybe<
    appointmentSubscriptionWhereInput[] | appointmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    appointmentSubscriptionWhereInput[] | appointmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    appointmentSubscriptionWhereInput[] | appointmentSubscriptionWhereInput
  >;
}

export interface daySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<dayWhereInput>;
  AND?: Maybe<daySubscriptionWhereInput[] | daySubscriptionWhereInput>;
  OR?: Maybe<daySubscriptionWhereInput[] | daySubscriptionWhereInput>;
  NOT?: Maybe<daySubscriptionWhereInput[] | daySubscriptionWhereInput>;
}

export interface departmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<departmentWhereInput>;
  AND?: Maybe<
    departmentSubscriptionWhereInput[] | departmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    departmentSubscriptionWhereInput[] | departmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    departmentSubscriptionWhereInput[] | departmentSubscriptionWhereInput
  >;
}

export interface establishmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<establishmentWhereInput>;
  AND?: Maybe<
    establishmentSubscriptionWhereInput[] | establishmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    establishmentSubscriptionWhereInput[] | establishmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    establishmentSubscriptionWhereInput[] | establishmentSubscriptionWhereInput
  >;
}

export interface hourSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<hourWhereInput>;
  AND?: Maybe<hourSubscriptionWhereInput[] | hourSubscriptionWhereInput>;
  OR?: Maybe<hourSubscriptionWhereInput[] | hourSubscriptionWhereInput>;
  NOT?: Maybe<hourSubscriptionWhereInput[] | hourSubscriptionWhereInput>;
}

export interface reportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<reportWhereInput>;
  AND?: Maybe<reportSubscriptionWhereInput[] | reportSubscriptionWhereInput>;
  OR?: Maybe<reportSubscriptionWhereInput[] | reportSubscriptionWhereInput>;
  NOT?: Maybe<reportSubscriptionWhereInput[] | reportSubscriptionWhereInput>;
}

export interface reviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<reviewWhereInput>;
  AND?: Maybe<reviewSubscriptionWhereInput[] | reviewSubscriptionWhereInput>;
  OR?: Maybe<reviewSubscriptionWhereInput[] | reviewSubscriptionWhereInput>;
  NOT?: Maybe<reviewSubscriptionWhereInput[] | reviewSubscriptionWhereInput>;
}

export interface serviceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<serviceWhereInput>;
  AND?: Maybe<serviceSubscriptionWhereInput[] | serviceSubscriptionWhereInput>;
  OR?: Maybe<serviceSubscriptionWhereInput[] | serviceSubscriptionWhereInput>;
  NOT?: Maybe<serviceSubscriptionWhereInput[] | serviceSubscriptionWhereInput>;
}

export interface typeofshiftSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<typeofshiftWhereInput>;
  AND?: Maybe<
    typeofshiftSubscriptionWhereInput[] | typeofshiftSubscriptionWhereInput
  >;
  OR?: Maybe<
    typeofshiftSubscriptionWhereInput[] | typeofshiftSubscriptionWhereInput
  >;
  NOT?: Maybe<
    typeofshiftSubscriptionWhereInput[] | typeofshiftSubscriptionWhereInput
  >;
}

export interface userSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<userWhereInput>;
  AND?: Maybe<userSubscriptionWhereInput[] | userSubscriptionWhereInput>;
  OR?: Maybe<userSubscriptionWhereInput[] | userSubscriptionWhereInput>;
  NOT?: Maybe<userSubscriptionWhereInput[] | userSubscriptionWhereInput>;
}

export interface userestablishmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<userestablishmentWhereInput>;
  AND?: Maybe<
    | userestablishmentSubscriptionWhereInput[]
    | userestablishmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | userestablishmentSubscriptionWhereInput[]
    | userestablishmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | userestablishmentSubscriptionWhereInput[]
    | userestablishmentSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface appointment {
  id: Int;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  endHour?: DateTimeOutput;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface appointmentPromise extends Promise<appointment>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface appointmentSubscription
  extends Promise<AsyncIterator<appointment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface appointmentNullablePromise
  extends Promise<appointment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface appointmentConnection {
  pageInfo: PageInfo;
  edges: appointmentEdge[];
}

export interface appointmentConnectionPromise
  extends Promise<appointmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<appointmentEdge>>() => T;
  aggregate: <T = AggregateappointmentPromise>() => T;
}

export interface appointmentConnectionSubscription
  extends Promise<AsyncIterator<appointmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<appointmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateappointmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface appointmentEdge {
  node: appointment;
  cursor: String;
}

export interface appointmentEdgePromise
  extends Promise<appointmentEdge>,
    Fragmentable {
  node: <T = appointmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface appointmentEdgeSubscription
  extends Promise<AsyncIterator<appointmentEdge>>,
    Fragmentable {
  node: <T = appointmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateappointment {
  count: Int;
}

export interface AggregateappointmentPromise
  extends Promise<Aggregateappointment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateappointmentSubscription
  extends Promise<AsyncIterator<Aggregateappointment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface day {
  id: Int;
  name: String;
}

export interface dayPromise extends Promise<day>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface daySubscription
  extends Promise<AsyncIterator<day>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface dayNullablePromise extends Promise<day | null>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface dayConnection {
  pageInfo: PageInfo;
  edges: dayEdge[];
}

export interface dayConnectionPromise
  extends Promise<dayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<dayEdge>>() => T;
  aggregate: <T = AggregatedayPromise>() => T;
}

export interface dayConnectionSubscription
  extends Promise<AsyncIterator<dayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<dayEdgeSubscription>>>() => T;
  aggregate: <T = AggregatedaySubscription>() => T;
}

export interface dayEdge {
  node: day;
  cursor: String;
}

export interface dayEdgePromise extends Promise<dayEdge>, Fragmentable {
  node: <T = dayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface dayEdgeSubscription
  extends Promise<AsyncIterator<dayEdge>>,
    Fragmentable {
  node: <T = daySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateday {
  count: Int;
}

export interface AggregatedayPromise
  extends Promise<Aggregateday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatedaySubscription
  extends Promise<AsyncIterator<Aggregateday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface department {
  id: Int;
  departmentCode?: Int;
  name?: String;
}

export interface departmentPromise extends Promise<department>, Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface departmentSubscription
  extends Promise<AsyncIterator<department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  departmentCode: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface departmentNullablePromise
  extends Promise<department | null>,
    Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface departmentConnection {
  pageInfo: PageInfo;
  edges: departmentEdge[];
}

export interface departmentConnectionPromise
  extends Promise<departmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<departmentEdge>>() => T;
  aggregate: <T = AggregatedepartmentPromise>() => T;
}

export interface departmentConnectionSubscription
  extends Promise<AsyncIterator<departmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<departmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatedepartmentSubscription>() => T;
}

export interface departmentEdge {
  node: department;
  cursor: String;
}

export interface departmentEdgePromise
  extends Promise<departmentEdge>,
    Fragmentable {
  node: <T = departmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface departmentEdgeSubscription
  extends Promise<AsyncIterator<departmentEdge>>,
    Fragmentable {
  node: <T = departmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatedepartment {
  count: Int;
}

export interface AggregatedepartmentPromise
  extends Promise<Aggregatedepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatedepartmentSubscription
  extends Promise<AsyncIterator<Aggregatedepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface establishment {
  id: Int;
  active: Boolean;
  address?: String;
  addressComplement?: String;
  city?: String;
  commercialName?: String;
  contactEmail?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  description?: String;
  illustration?: String;
  name?: String;
  phoneNumber?: String;
  siret?: String;
  updatedAt: DateTimeOutput;
  zipCode?: String;
}

export interface establishmentPromise
  extends Promise<establishment>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zipCode: () => Promise<String>;
}

export interface establishmentSubscription
  extends Promise<AsyncIterator<establishment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  address: () => Promise<AsyncIterator<String>>;
  addressComplement: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  commercialName: () => Promise<AsyncIterator<String>>;
  contactEmail: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  siret: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface establishmentNullablePromise
  extends Promise<establishment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zipCode: () => Promise<String>;
}

export interface establishmentConnection {
  pageInfo: PageInfo;
  edges: establishmentEdge[];
}

export interface establishmentConnectionPromise
  extends Promise<establishmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<establishmentEdge>>() => T;
  aggregate: <T = AggregateestablishmentPromise>() => T;
}

export interface establishmentConnectionSubscription
  extends Promise<AsyncIterator<establishmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<establishmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateestablishmentSubscription>() => T;
}

export interface establishmentEdge {
  node: establishment;
  cursor: String;
}

export interface establishmentEdgePromise
  extends Promise<establishmentEdge>,
    Fragmentable {
  node: <T = establishmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface establishmentEdgeSubscription
  extends Promise<AsyncIterator<establishmentEdge>>,
    Fragmentable {
  node: <T = establishmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateestablishment {
  count: Int;
}

export interface AggregateestablishmentPromise
  extends Promise<Aggregateestablishment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateestablishmentSubscription
  extends Promise<AsyncIterator<Aggregateestablishment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface hour {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  endHour?: DateTimeOutput;
  nbBarber?: Int;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface hourPromise extends Promise<hour>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface hourSubscription
  extends Promise<AsyncIterator<hour>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  nbBarber: () => Promise<AsyncIterator<Int>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface hourNullablePromise
  extends Promise<hour | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface hourConnection {
  pageInfo: PageInfo;
  edges: hourEdge[];
}

export interface hourConnectionPromise
  extends Promise<hourConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<hourEdge>>() => T;
  aggregate: <T = AggregatehourPromise>() => T;
}

export interface hourConnectionSubscription
  extends Promise<AsyncIterator<hourConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<hourEdgeSubscription>>>() => T;
  aggregate: <T = AggregatehourSubscription>() => T;
}

export interface hourEdge {
  node: hour;
  cursor: String;
}

export interface hourEdgePromise extends Promise<hourEdge>, Fragmentable {
  node: <T = hourPromise>() => T;
  cursor: () => Promise<String>;
}

export interface hourEdgeSubscription
  extends Promise<AsyncIterator<hourEdge>>,
    Fragmentable {
  node: <T = hourSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatehour {
  count: Int;
}

export interface AggregatehourPromise
  extends Promise<Aggregatehour>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatehourSubscription
  extends Promise<AsyncIterator<Aggregatehour>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface report {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title?: String;
  updatedAt: DateTimeOutput;
}

export interface reportPromise extends Promise<report>, Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reportSubscription
  extends Promise<AsyncIterator<report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface reportNullablePromise
  extends Promise<report | null>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reportConnection {
  pageInfo: PageInfo;
  edges: reportEdge[];
}

export interface reportConnectionPromise
  extends Promise<reportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<reportEdge>>() => T;
  aggregate: <T = AggregatereportPromise>() => T;
}

export interface reportConnectionSubscription
  extends Promise<AsyncIterator<reportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<reportEdgeSubscription>>>() => T;
  aggregate: <T = AggregatereportSubscription>() => T;
}

export interface reportEdge {
  node: report;
  cursor: String;
}

export interface reportEdgePromise extends Promise<reportEdge>, Fragmentable {
  node: <T = reportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface reportEdgeSubscription
  extends Promise<AsyncIterator<reportEdge>>,
    Fragmentable {
  node: <T = reportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatereport {
  count: Int;
}

export interface AggregatereportPromise
  extends Promise<Aggregatereport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatereportSubscription
  extends Promise<AsyncIterator<Aggregatereport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface review {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  mark?: Int;
  updatedAt: DateTimeOutput;
}

export interface reviewPromise extends Promise<review>, Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reviewSubscription
  extends Promise<AsyncIterator<review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  mark: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface reviewNullablePromise
  extends Promise<review | null>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reviewConnection {
  pageInfo: PageInfo;
  edges: reviewEdge[];
}

export interface reviewConnectionPromise
  extends Promise<reviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<reviewEdge>>() => T;
  aggregate: <T = AggregatereviewPromise>() => T;
}

export interface reviewConnectionSubscription
  extends Promise<AsyncIterator<reviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<reviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregatereviewSubscription>() => T;
}

export interface reviewEdge {
  node: review;
  cursor: String;
}

export interface reviewEdgePromise extends Promise<reviewEdge>, Fragmentable {
  node: <T = reviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface reviewEdgeSubscription
  extends Promise<AsyncIterator<reviewEdge>>,
    Fragmentable {
  node: <T = reviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatereview {
  count: Int;
}

export interface AggregatereviewPromise
  extends Promise<Aggregatereview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatereviewSubscription
  extends Promise<AsyncIterator<Aggregatereview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface service {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  duration?: Int;
  illustration?: String;
  name?: String;
  price?: Float;
  updatedAt: DateTimeOutput;
}

export interface servicePromise extends Promise<service>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface serviceSubscription
  extends Promise<AsyncIterator<service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface serviceNullablePromise
  extends Promise<service | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface serviceConnection {
  pageInfo: PageInfo;
  edges: serviceEdge[];
}

export interface serviceConnectionPromise
  extends Promise<serviceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<serviceEdge>>() => T;
  aggregate: <T = AggregateservicePromise>() => T;
}

export interface serviceConnectionSubscription
  extends Promise<AsyncIterator<serviceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<serviceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateserviceSubscription>() => T;
}

export interface serviceEdge {
  node: service;
  cursor: String;
}

export interface serviceEdgePromise extends Promise<serviceEdge>, Fragmentable {
  node: <T = servicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface serviceEdgeSubscription
  extends Promise<AsyncIterator<serviceEdge>>,
    Fragmentable {
  node: <T = serviceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateservice {
  count: Int;
}

export interface AggregateservicePromise
  extends Promise<Aggregateservice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateserviceSubscription
  extends Promise<AsyncIterator<Aggregateservice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface typeofshift {
  id: Int;
  name?: String;
}

export interface typeofshiftPromise extends Promise<typeofshift>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface typeofshiftSubscription
  extends Promise<AsyncIterator<typeofshift>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface typeofshiftNullablePromise
  extends Promise<typeofshift | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface typeofshiftConnection {
  pageInfo: PageInfo;
  edges: typeofshiftEdge[];
}

export interface typeofshiftConnectionPromise
  extends Promise<typeofshiftConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<typeofshiftEdge>>() => T;
  aggregate: <T = AggregatetypeofshiftPromise>() => T;
}

export interface typeofshiftConnectionSubscription
  extends Promise<AsyncIterator<typeofshiftConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<typeofshiftEdgeSubscription>>>() => T;
  aggregate: <T = AggregatetypeofshiftSubscription>() => T;
}

export interface typeofshiftEdge {
  node: typeofshift;
  cursor: String;
}

export interface typeofshiftEdgePromise
  extends Promise<typeofshiftEdge>,
    Fragmentable {
  node: <T = typeofshiftPromise>() => T;
  cursor: () => Promise<String>;
}

export interface typeofshiftEdgeSubscription
  extends Promise<AsyncIterator<typeofshiftEdge>>,
    Fragmentable {
  node: <T = typeofshiftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatetypeofshift {
  count: Int;
}

export interface AggregatetypeofshiftPromise
  extends Promise<Aggregatetypeofshift>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatetypeofshiftSubscription
  extends Promise<AsyncIterator<Aggregatetypeofshift>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface user {
  id: Int;
  active: Boolean;
  birthdate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  email: String;
  firstname?: String;
  gender?: String;
  lastname?: String;
  password: String;
  phoneNumber?: String;
  roles: Json;
  updatedAt: DateTimeOutput;
}

export interface userPromise extends Promise<user>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface userSubscription
  extends Promise<AsyncIterator<user>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Json>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface userNullablePromise
  extends Promise<user | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface userConnection {
  pageInfo: PageInfo;
  edges: userEdge[];
}

export interface userConnectionPromise
  extends Promise<userConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<userEdge>>() => T;
  aggregate: <T = AggregateuserPromise>() => T;
}

export interface userConnectionSubscription
  extends Promise<AsyncIterator<userConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<userEdgeSubscription>>>() => T;
  aggregate: <T = AggregateuserSubscription>() => T;
}

export interface userEdge {
  node: user;
  cursor: String;
}

export interface userEdgePromise extends Promise<userEdge>, Fragmentable {
  node: <T = userPromise>() => T;
  cursor: () => Promise<String>;
}

export interface userEdgeSubscription
  extends Promise<AsyncIterator<userEdge>>,
    Fragmentable {
  node: <T = userSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateuser {
  count: Int;
}

export interface AggregateuserPromise
  extends Promise<Aggregateuser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateuserSubscription
  extends Promise<AsyncIterator<Aggregateuser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface userestablishment {
  id: Int;
  deletedAt?: DateTimeOutput;
  validated?: Boolean;
}

export interface userestablishmentPromise
  extends Promise<userestablishment>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  validated: () => Promise<Boolean>;
}

export interface userestablishmentSubscription
  extends Promise<AsyncIterator<userestablishment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validated: () => Promise<AsyncIterator<Boolean>>;
}

export interface userestablishmentNullablePromise
  extends Promise<userestablishment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  validated: () => Promise<Boolean>;
}

export interface userestablishmentConnection {
  pageInfo: PageInfo;
  edges: userestablishmentEdge[];
}

export interface userestablishmentConnectionPromise
  extends Promise<userestablishmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<userestablishmentEdge>>() => T;
  aggregate: <T = AggregateuserestablishmentPromise>() => T;
}

export interface userestablishmentConnectionSubscription
  extends Promise<AsyncIterator<userestablishmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<userestablishmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateuserestablishmentSubscription>() => T;
}

export interface userestablishmentEdge {
  node: userestablishment;
  cursor: String;
}

export interface userestablishmentEdgePromise
  extends Promise<userestablishmentEdge>,
    Fragmentable {
  node: <T = userestablishmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface userestablishmentEdgeSubscription
  extends Promise<AsyncIterator<userestablishmentEdge>>,
    Fragmentable {
  node: <T = userestablishmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateuserestablishment {
  count: Int;
}

export interface AggregateuserestablishmentPromise
  extends Promise<Aggregateuserestablishment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateuserestablishmentSubscription
  extends Promise<AsyncIterator<Aggregateuserestablishment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface appointmentSubscriptionPayload {
  mutation: MutationType;
  node: appointment;
  updatedFields: String[];
  previousValues: appointmentPreviousValues;
}

export interface appointmentSubscriptionPayloadPromise
  extends Promise<appointmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = appointmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = appointmentPreviousValuesPromise>() => T;
}

export interface appointmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<appointmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = appointmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = appointmentPreviousValuesSubscription>() => T;
}

export interface appointmentPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  endHour?: DateTimeOutput;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface appointmentPreviousValuesPromise
  extends Promise<appointmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface appointmentPreviousValuesSubscription
  extends Promise<AsyncIterator<appointmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface daySubscriptionPayload {
  mutation: MutationType;
  node: day;
  updatedFields: String[];
  previousValues: dayPreviousValues;
}

export interface daySubscriptionPayloadPromise
  extends Promise<daySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = dayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = dayPreviousValuesPromise>() => T;
}

export interface daySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<daySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = daySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = dayPreviousValuesSubscription>() => T;
}

export interface dayPreviousValues {
  id: Int;
  name: String;
}

export interface dayPreviousValuesPromise
  extends Promise<dayPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface dayPreviousValuesSubscription
  extends Promise<AsyncIterator<dayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface departmentSubscriptionPayload {
  mutation: MutationType;
  node: department;
  updatedFields: String[];
  previousValues: departmentPreviousValues;
}

export interface departmentSubscriptionPayloadPromise
  extends Promise<departmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = departmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = departmentPreviousValuesPromise>() => T;
}

export interface departmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<departmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = departmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = departmentPreviousValuesSubscription>() => T;
}

export interface departmentPreviousValues {
  id: Int;
  departmentCode?: Int;
  name?: String;
}

export interface departmentPreviousValuesPromise
  extends Promise<departmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface departmentPreviousValuesSubscription
  extends Promise<AsyncIterator<departmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  departmentCode: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface establishmentSubscriptionPayload {
  mutation: MutationType;
  node: establishment;
  updatedFields: String[];
  previousValues: establishmentPreviousValues;
}

export interface establishmentSubscriptionPayloadPromise
  extends Promise<establishmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = establishmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = establishmentPreviousValuesPromise>() => T;
}

export interface establishmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<establishmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = establishmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = establishmentPreviousValuesSubscription>() => T;
}

export interface establishmentPreviousValues {
  id: Int;
  active: Boolean;
  address?: String;
  addressComplement?: String;
  city?: String;
  commercialName?: String;
  contactEmail?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  description?: String;
  illustration?: String;
  name?: String;
  phoneNumber?: String;
  siret?: String;
  updatedAt: DateTimeOutput;
  zipCode?: String;
}

export interface establishmentPreviousValuesPromise
  extends Promise<establishmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zipCode: () => Promise<String>;
}

export interface establishmentPreviousValuesSubscription
  extends Promise<AsyncIterator<establishmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  address: () => Promise<AsyncIterator<String>>;
  addressComplement: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  commercialName: () => Promise<AsyncIterator<String>>;
  contactEmail: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  siret: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface hourSubscriptionPayload {
  mutation: MutationType;
  node: hour;
  updatedFields: String[];
  previousValues: hourPreviousValues;
}

export interface hourSubscriptionPayloadPromise
  extends Promise<hourSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = hourPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = hourPreviousValuesPromise>() => T;
}

export interface hourSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<hourSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = hourSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = hourPreviousValuesSubscription>() => T;
}

export interface hourPreviousValues {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  endHour?: DateTimeOutput;
  nbBarber?: Int;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface hourPreviousValuesPromise
  extends Promise<hourPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface hourPreviousValuesSubscription
  extends Promise<AsyncIterator<hourPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  nbBarber: () => Promise<AsyncIterator<Int>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface reportSubscriptionPayload {
  mutation: MutationType;
  node: report;
  updatedFields: String[];
  previousValues: reportPreviousValues;
}

export interface reportSubscriptionPayloadPromise
  extends Promise<reportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = reportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = reportPreviousValuesPromise>() => T;
}

export interface reportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<reportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = reportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = reportPreviousValuesSubscription>() => T;
}

export interface reportPreviousValues {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title?: String;
  updatedAt: DateTimeOutput;
}

export interface reportPreviousValuesPromise
  extends Promise<reportPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reportPreviousValuesSubscription
  extends Promise<AsyncIterator<reportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface reviewSubscriptionPayload {
  mutation: MutationType;
  node: review;
  updatedFields: String[];
  previousValues: reviewPreviousValues;
}

export interface reviewSubscriptionPayloadPromise
  extends Promise<reviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = reviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = reviewPreviousValuesPromise>() => T;
}

export interface reviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<reviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = reviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = reviewPreviousValuesSubscription>() => T;
}

export interface reviewPreviousValues {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  mark?: Int;
  updatedAt: DateTimeOutput;
}

export interface reviewPreviousValuesPromise
  extends Promise<reviewPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface reviewPreviousValuesSubscription
  extends Promise<AsyncIterator<reviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  mark: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface serviceSubscriptionPayload {
  mutation: MutationType;
  node: service;
  updatedFields: String[];
  previousValues: servicePreviousValues;
}

export interface serviceSubscriptionPayloadPromise
  extends Promise<serviceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = servicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = servicePreviousValuesPromise>() => T;
}

export interface serviceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<serviceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = serviceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = servicePreviousValuesSubscription>() => T;
}

export interface servicePreviousValues {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  duration?: Int;
  illustration?: String;
  name?: String;
  price?: Float;
  updatedAt: DateTimeOutput;
}

export interface servicePreviousValuesPromise
  extends Promise<servicePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface servicePreviousValuesSubscription
  extends Promise<AsyncIterator<servicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface typeofshiftSubscriptionPayload {
  mutation: MutationType;
  node: typeofshift;
  updatedFields: String[];
  previousValues: typeofshiftPreviousValues;
}

export interface typeofshiftSubscriptionPayloadPromise
  extends Promise<typeofshiftSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = typeofshiftPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = typeofshiftPreviousValuesPromise>() => T;
}

export interface typeofshiftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<typeofshiftSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = typeofshiftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = typeofshiftPreviousValuesSubscription>() => T;
}

export interface typeofshiftPreviousValues {
  id: Int;
  name?: String;
}

export interface typeofshiftPreviousValuesPromise
  extends Promise<typeofshiftPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface typeofshiftPreviousValuesSubscription
  extends Promise<AsyncIterator<typeofshiftPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface userSubscriptionPayload {
  mutation: MutationType;
  node: user;
  updatedFields: String[];
  previousValues: userPreviousValues;
}

export interface userSubscriptionPayloadPromise
  extends Promise<userSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = userPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = userPreviousValuesPromise>() => T;
}

export interface userSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<userSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = userSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = userPreviousValuesSubscription>() => T;
}

export interface userPreviousValues {
  id: Int;
  active: Boolean;
  birthdate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  email: String;
  firstname?: String;
  gender?: String;
  lastname?: String;
  password: String;
  phoneNumber?: String;
  roles: Json;
  updatedAt: DateTimeOutput;
}

export interface userPreviousValuesPromise
  extends Promise<userPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface userPreviousValuesSubscription
  extends Promise<AsyncIterator<userPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Json>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface userestablishmentSubscriptionPayload {
  mutation: MutationType;
  node: userestablishment;
  updatedFields: String[];
  previousValues: userestablishmentPreviousValues;
}

export interface userestablishmentSubscriptionPayloadPromise
  extends Promise<userestablishmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = userestablishmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = userestablishmentPreviousValuesPromise>() => T;
}

export interface userestablishmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<userestablishmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = userestablishmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = userestablishmentPreviousValuesSubscription>() => T;
}

export interface userestablishmentPreviousValues {
  id: Int;
  deletedAt?: DateTimeOutput;
  validated?: Boolean;
}

export interface userestablishmentPreviousValuesPromise
  extends Promise<userestablishmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  validated: () => Promise<Boolean>;
}

export interface userestablishmentPreviousValuesSubscription
  extends Promise<AsyncIterator<userestablishmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validated: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "day",
    embedded: false
  },
  {
    name: "appointment",
    embedded: false
  },
  {
    name: "department",
    embedded: false
  },
  {
    name: "establishment",
    embedded: false
  },
  {
    name: "hour",
    embedded: false
  },
  {
    name: "report",
    embedded: false
  },
  {
    name: "review",
    embedded: false
  },
  {
    name: "service",
    embedded: false
  },
  {
    name: "typeofshift",
    embedded: false
  },
  {
    name: "user",
    embedded: false
  },
  {
    name: "userestablishment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
