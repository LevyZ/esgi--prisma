// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  appointment: (where?: AppointmentWhereInput) => Promise<boolean>;
  appointmentStatus: (where?: AppointmentStatusWhereInput) => Promise<boolean>;
  day: (where?: DayWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  establishment: (where?: EstablishmentWhereInput) => Promise<boolean>;
  hour: (where?: HourWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  typeOfShift: (where?: TypeOfShiftWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userEstablishment: (where?: UserEstablishmentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  appointment: (
    where: AppointmentWhereUniqueInput
  ) => AppointmentNullablePromise;
  appointments: (args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Appointment>;
  appointmentsConnection: (args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppointmentConnectionPromise;
  appointmentStatus: (
    where: AppointmentStatusWhereUniqueInput
  ) => AppointmentStatusNullablePromise;
  appointmentStatuses: (args?: {
    where?: AppointmentStatusWhereInput;
    orderBy?: AppointmentStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AppointmentStatus>;
  appointmentStatusesConnection: (args?: {
    where?: AppointmentStatusWhereInput;
    orderBy?: AppointmentStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppointmentStatusConnectionPromise;
  day: (where: DayWhereUniqueInput) => DayNullablePromise;
  days: (args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Day>;
  daysConnection: (args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DayConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  establishment: (
    where: EstablishmentWhereUniqueInput
  ) => EstablishmentNullablePromise;
  establishments: (args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Establishment>;
  establishmentsConnection: (args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EstablishmentConnectionPromise;
  hour: (where: HourWhereUniqueInput) => HourNullablePromise;
  hours: (args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Hour>;
  hoursConnection: (args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HourConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServiceNullablePromise;
  services: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Service>;
  servicesConnection: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceConnectionPromise;
  typeOfShift: (
    where: TypeOfShiftWhereUniqueInput
  ) => TypeOfShiftNullablePromise;
  typeOfShifts: (args?: {
    where?: TypeOfShiftWhereInput;
    orderBy?: TypeOfShiftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TypeOfShift>;
  typeOfShiftsConnection: (args?: {
    where?: TypeOfShiftWhereInput;
    orderBy?: TypeOfShiftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TypeOfShiftConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userEstablishment: (
    where: UserEstablishmentWhereUniqueInput
  ) => UserEstablishmentNullablePromise;
  userEstablishments: (args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserEstablishment>;
  userEstablishmentsConnection: (args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserEstablishmentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAppointment: (data: AppointmentCreateInput) => AppointmentPromise;
  updateAppointment: (args: {
    data: AppointmentUpdateInput;
    where: AppointmentWhereUniqueInput;
  }) => AppointmentPromise;
  updateManyAppointments: (args: {
    data: AppointmentUpdateManyMutationInput;
    where?: AppointmentWhereInput;
  }) => BatchPayloadPromise;
  upsertAppointment: (args: {
    where: AppointmentWhereUniqueInput;
    create: AppointmentCreateInput;
    update: AppointmentUpdateInput;
  }) => AppointmentPromise;
  deleteAppointment: (where: AppointmentWhereUniqueInput) => AppointmentPromise;
  deleteManyAppointments: (
    where?: AppointmentWhereInput
  ) => BatchPayloadPromise;
  createAppointmentStatus: (
    data: AppointmentStatusCreateInput
  ) => AppointmentStatusPromise;
  updateAppointmentStatus: (args: {
    data: AppointmentStatusUpdateInput;
    where: AppointmentStatusWhereUniqueInput;
  }) => AppointmentStatusPromise;
  updateManyAppointmentStatuses: (args: {
    data: AppointmentStatusUpdateManyMutationInput;
    where?: AppointmentStatusWhereInput;
  }) => BatchPayloadPromise;
  upsertAppointmentStatus: (args: {
    where: AppointmentStatusWhereUniqueInput;
    create: AppointmentStatusCreateInput;
    update: AppointmentStatusUpdateInput;
  }) => AppointmentStatusPromise;
  deleteAppointmentStatus: (
    where: AppointmentStatusWhereUniqueInput
  ) => AppointmentStatusPromise;
  deleteManyAppointmentStatuses: (
    where?: AppointmentStatusWhereInput
  ) => BatchPayloadPromise;
  createDay: (data: DayCreateInput) => DayPromise;
  updateDay: (args: {
    data: DayUpdateInput;
    where: DayWhereUniqueInput;
  }) => DayPromise;
  updateManyDays: (args: {
    data: DayUpdateManyMutationInput;
    where?: DayWhereInput;
  }) => BatchPayloadPromise;
  upsertDay: (args: {
    where: DayWhereUniqueInput;
    create: DayCreateInput;
    update: DayUpdateInput;
  }) => DayPromise;
  deleteDay: (where: DayWhereUniqueInput) => DayPromise;
  deleteManyDays: (where?: DayWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createEstablishment: (data: EstablishmentCreateInput) => EstablishmentPromise;
  updateEstablishment: (args: {
    data: EstablishmentUpdateInput;
    where: EstablishmentWhereUniqueInput;
  }) => EstablishmentPromise;
  updateManyEstablishments: (args: {
    data: EstablishmentUpdateManyMutationInput;
    where?: EstablishmentWhereInput;
  }) => BatchPayloadPromise;
  upsertEstablishment: (args: {
    where: EstablishmentWhereUniqueInput;
    create: EstablishmentCreateInput;
    update: EstablishmentUpdateInput;
  }) => EstablishmentPromise;
  deleteEstablishment: (
    where: EstablishmentWhereUniqueInput
  ) => EstablishmentPromise;
  deleteManyEstablishments: (
    where?: EstablishmentWhereInput
  ) => BatchPayloadPromise;
  createHour: (data: HourCreateInput) => HourPromise;
  updateHour: (args: {
    data: HourUpdateInput;
    where: HourWhereUniqueInput;
  }) => HourPromise;
  updateManyHours: (args: {
    data: HourUpdateManyMutationInput;
    where?: HourWhereInput;
  }) => BatchPayloadPromise;
  upsertHour: (args: {
    where: HourWhereUniqueInput;
    create: HourCreateInput;
    update: HourUpdateInput;
  }) => HourPromise;
  deleteHour: (where: HourWhereUniqueInput) => HourPromise;
  deleteManyHours: (where?: HourWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: {
    data: ReportUpdateInput;
    where: ReportWhereUniqueInput;
  }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (args: {
    data: ServiceUpdateInput;
    where: ServiceWhereUniqueInput;
  }) => ServicePromise;
  updateManyServices: (args: {
    data: ServiceUpdateManyMutationInput;
    where?: ServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertService: (args: {
    where: ServiceWhereUniqueInput;
    create: ServiceCreateInput;
    update: ServiceUpdateInput;
  }) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createTypeOfShift: (data: TypeOfShiftCreateInput) => TypeOfShiftPromise;
  updateTypeOfShift: (args: {
    data: TypeOfShiftUpdateInput;
    where: TypeOfShiftWhereUniqueInput;
  }) => TypeOfShiftPromise;
  updateManyTypeOfShifts: (args: {
    data: TypeOfShiftUpdateManyMutationInput;
    where?: TypeOfShiftWhereInput;
  }) => BatchPayloadPromise;
  upsertTypeOfShift: (args: {
    where: TypeOfShiftWhereUniqueInput;
    create: TypeOfShiftCreateInput;
    update: TypeOfShiftUpdateInput;
  }) => TypeOfShiftPromise;
  deleteTypeOfShift: (where: TypeOfShiftWhereUniqueInput) => TypeOfShiftPromise;
  deleteManyTypeOfShifts: (
    where?: TypeOfShiftWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserEstablishment: (
    data: UserEstablishmentCreateInput
  ) => UserEstablishmentPromise;
  updateUserEstablishment: (args: {
    data: UserEstablishmentUpdateInput;
    where: UserEstablishmentWhereUniqueInput;
  }) => UserEstablishmentPromise;
  updateManyUserEstablishments: (args: {
    data: UserEstablishmentUpdateManyMutationInput;
    where?: UserEstablishmentWhereInput;
  }) => BatchPayloadPromise;
  upsertUserEstablishment: (args: {
    where: UserEstablishmentWhereUniqueInput;
    create: UserEstablishmentCreateInput;
    update: UserEstablishmentUpdateInput;
  }) => UserEstablishmentPromise;
  deleteUserEstablishment: (
    where: UserEstablishmentWhereUniqueInput
  ) => UserEstablishmentPromise;
  deleteManyUserEstablishments: (
    where?: UserEstablishmentWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  appointment: (
    where?: AppointmentSubscriptionWhereInput
  ) => AppointmentSubscriptionPayloadSubscription;
  appointmentStatus: (
    where?: AppointmentStatusSubscriptionWhereInput
  ) => AppointmentStatusSubscriptionPayloadSubscription;
  day: (
    where?: DaySubscriptionWhereInput
  ) => DaySubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  establishment: (
    where?: EstablishmentSubscriptionWhereInput
  ) => EstablishmentSubscriptionPayloadSubscription;
  hour: (
    where?: HourSubscriptionWhereInput
  ) => HourSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  typeOfShift: (
    where?: TypeOfShiftSubscriptionWhereInput
  ) => TypeOfShiftSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userEstablishment: (
    where?: UserEstablishmentSubscriptionWhereInput
  ) => UserEstablishmentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AppointmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "endHour_ASC"
  | "endHour_DESC"
  | "startHour_ASC"
  | "startHour_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EstablishmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "address_ASC"
  | "address_DESC"
  | "addressComplement_ASC"
  | "addressComplement_DESC"
  | "city_ASC"
  | "city_DESC"
  | "commercialName_ASC"
  | "commercialName_DESC"
  | "contactEmail_ASC"
  | "contactEmail_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "illustration_ASC"
  | "illustration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "siret_ASC"
  | "siret_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC";

export type HourOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "endHour_ASC"
  | "endHour_DESC"
  | "nbBarber_ASC"
  | "nbBarber_DESC"
  | "startHour_ASC"
  | "startHour_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "mark_ASC"
  | "mark_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "illustration_ASC"
  | "illustration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserEstablishmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "validated_ASC"
  | "validated_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "birthdate_ASC"
  | "birthdate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "roles_ASC"
  | "roles_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AppointmentStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type DayOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "departmentCode_ASC"
  | "departmentCode_DESC"
  | "name_ASC"
  | "name_DESC";

export type TypeOfShiftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AppointmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AppointmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  appointmentStatus?: Maybe<AppointmentStatusWhereInput>;
  client?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
  OR?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
  NOT?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
}

export interface AppointmentStatusWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  appointment_every?: Maybe<AppointmentWhereInput>;
  appointment_some?: Maybe<AppointmentWhereInput>;
  appointment_none?: Maybe<AppointmentWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AppointmentStatusWhereInput[] | AppointmentStatusWhereInput>;
  OR?: Maybe<AppointmentStatusWhereInput[] | AppointmentStatusWhereInput>;
  NOT?: Maybe<AppointmentStatusWhereInput[] | AppointmentStatusWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  appointment_every?: Maybe<AppointmentWhereInput>;
  appointment_some?: Maybe<AppointmentWhereInput>;
  appointment_none?: Maybe<AppointmentWhereInput>;
  birthdate?: Maybe<DateTimeInput>;
  birthdate_not?: Maybe<DateTimeInput>;
  birthdate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_lt?: Maybe<DateTimeInput>;
  birthdate_lte?: Maybe<DateTimeInput>;
  birthdate_gt?: Maybe<DateTimeInput>;
  birthdate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  establishment_every?: Maybe<EstablishmentWhereInput>;
  establishment_some?: Maybe<EstablishmentWhereInput>;
  establishment_none?: Maybe<EstablishmentWhereInput>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  report_every?: Maybe<ReportWhereInput>;
  report_some?: Maybe<ReportWhereInput>;
  report_none?: Maybe<ReportWhereInput>;
  review_every?: Maybe<ReviewWhereInput>;
  review_some?: Maybe<ReviewWhereInput>;
  review_none?: Maybe<ReviewWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  userEstablishment_every?: Maybe<UserEstablishmentWhereInput>;
  userEstablishment_some?: Maybe<UserEstablishmentWhereInput>;
  userEstablishment_none?: Maybe<UserEstablishmentWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface DepartmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  departmentCode_not?: Maybe<Int>;
  departmentCode_in?: Maybe<Int[] | Int>;
  departmentCode_not_in?: Maybe<Int[] | Int>;
  departmentCode_lt?: Maybe<Int>;
  departmentCode_lte?: Maybe<Int>;
  departmentCode_gt?: Maybe<Int>;
  departmentCode_gte?: Maybe<Int>;
  establishment_every?: Maybe<EstablishmentWhereInput>;
  establishment_some?: Maybe<EstablishmentWhereInput>;
  establishment_none?: Maybe<EstablishmentWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  user_every?: Maybe<UserWhereInput>;
  user_some?: Maybe<UserWhereInput>;
  user_none?: Maybe<UserWhereInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface EstablishmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  addressComplement?: Maybe<String>;
  addressComplement_not?: Maybe<String>;
  addressComplement_in?: Maybe<String[] | String>;
  addressComplement_not_in?: Maybe<String[] | String>;
  addressComplement_lt?: Maybe<String>;
  addressComplement_lte?: Maybe<String>;
  addressComplement_gt?: Maybe<String>;
  addressComplement_gte?: Maybe<String>;
  addressComplement_contains?: Maybe<String>;
  addressComplement_not_contains?: Maybe<String>;
  addressComplement_starts_with?: Maybe<String>;
  addressComplement_not_starts_with?: Maybe<String>;
  addressComplement_ends_with?: Maybe<String>;
  addressComplement_not_ends_with?: Maybe<String>;
  appointment_every?: Maybe<AppointmentWhereInput>;
  appointment_some?: Maybe<AppointmentWhereInput>;
  appointment_none?: Maybe<AppointmentWhereInput>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  commercialName?: Maybe<String>;
  commercialName_not?: Maybe<String>;
  commercialName_in?: Maybe<String[] | String>;
  commercialName_not_in?: Maybe<String[] | String>;
  commercialName_lt?: Maybe<String>;
  commercialName_lte?: Maybe<String>;
  commercialName_gt?: Maybe<String>;
  commercialName_gte?: Maybe<String>;
  commercialName_contains?: Maybe<String>;
  commercialName_not_contains?: Maybe<String>;
  commercialName_starts_with?: Maybe<String>;
  commercialName_not_starts_with?: Maybe<String>;
  commercialName_ends_with?: Maybe<String>;
  commercialName_not_ends_with?: Maybe<String>;
  contactEmail?: Maybe<String>;
  contactEmail_not?: Maybe<String>;
  contactEmail_in?: Maybe<String[] | String>;
  contactEmail_not_in?: Maybe<String[] | String>;
  contactEmail_lt?: Maybe<String>;
  contactEmail_lte?: Maybe<String>;
  contactEmail_gt?: Maybe<String>;
  contactEmail_gte?: Maybe<String>;
  contactEmail_contains?: Maybe<String>;
  contactEmail_not_contains?: Maybe<String>;
  contactEmail_starts_with?: Maybe<String>;
  contactEmail_not_starts_with?: Maybe<String>;
  contactEmail_ends_with?: Maybe<String>;
  contactEmail_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  hours_every?: Maybe<HourWhereInput>;
  hours_some?: Maybe<HourWhereInput>;
  hours_none?: Maybe<HourWhereInput>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  owner?: Maybe<UserWhereInput>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  report_every?: Maybe<ReportWhereInput>;
  report_some?: Maybe<ReportWhereInput>;
  report_none?: Maybe<ReportWhereInput>;
  review_every?: Maybe<ReviewWhereInput>;
  review_some?: Maybe<ReviewWhereInput>;
  review_none?: Maybe<ReviewWhereInput>;
  service_every?: Maybe<ServiceWhereInput>;
  service_some?: Maybe<ServiceWhereInput>;
  service_none?: Maybe<ServiceWhereInput>;
  siret?: Maybe<String>;
  siret_not?: Maybe<String>;
  siret_in?: Maybe<String[] | String>;
  siret_not_in?: Maybe<String[] | String>;
  siret_lt?: Maybe<String>;
  siret_lte?: Maybe<String>;
  siret_gt?: Maybe<String>;
  siret_gte?: Maybe<String>;
  siret_contains?: Maybe<String>;
  siret_not_contains?: Maybe<String>;
  siret_starts_with?: Maybe<String>;
  siret_not_starts_with?: Maybe<String>;
  siret_ends_with?: Maybe<String>;
  siret_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  userEstablishment_every?: Maybe<UserEstablishmentWhereInput>;
  userEstablishment_some?: Maybe<UserEstablishmentWhereInput>;
  userEstablishment_none?: Maybe<UserEstablishmentWhereInput>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
  OR?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
  NOT?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
}

export interface HourWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  day?: Maybe<DayWhereInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  nbBarber?: Maybe<Int>;
  nbBarber_not?: Maybe<Int>;
  nbBarber_in?: Maybe<Int[] | Int>;
  nbBarber_not_in?: Maybe<Int[] | Int>;
  nbBarber_lt?: Maybe<Int>;
  nbBarber_lte?: Maybe<Int>;
  nbBarber_gt?: Maybe<Int>;
  nbBarber_gte?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HourWhereInput[] | HourWhereInput>;
  OR?: Maybe<HourWhereInput[] | HourWhereInput>;
  NOT?: Maybe<HourWhereInput[] | HourWhereInput>;
}

export interface DayWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  hours_every?: Maybe<HourWhereInput>;
  hours_some?: Maybe<HourWhereInput>;
  hours_none?: Maybe<HourWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<DayWhereInput[] | DayWhereInput>;
  OR?: Maybe<DayWhereInput[] | DayWhereInput>;
  NOT?: Maybe<DayWhereInput[] | DayWhereInput>;
}

export interface TypeOfShiftWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  hours_every?: Maybe<HourWhereInput>;
  hours_some?: Maybe<HourWhereInput>;
  hours_none?: Maybe<HourWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TypeOfShiftWhereInput[] | TypeOfShiftWhereInput>;
  OR?: Maybe<TypeOfShiftWhereInput[] | TypeOfShiftWhereInput>;
  NOT?: Maybe<TypeOfShiftWhereInput[] | TypeOfShiftWhereInput>;
}

export interface ReportWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  author?: Maybe<UserWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export interface ReviewWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  author?: Maybe<UserWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  mark?: Maybe<Int>;
  mark_not?: Maybe<Int>;
  mark_in?: Maybe<Int[] | Int>;
  mark_not_in?: Maybe<Int[] | Int>;
  mark_lt?: Maybe<Int>;
  mark_lte?: Maybe<Int>;
  mark_gt?: Maybe<Int>;
  mark_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface ServiceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  establishment?: Maybe<EstablishmentWhereInput>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  updatedBy?: Maybe<UserWhereInput>;
  AND?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  OR?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  NOT?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
}

export interface UserEstablishmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  manager?: Maybe<UserWhereInput>;
  validated?: Maybe<Boolean>;
  validated_not?: Maybe<Boolean>;
  AND?: Maybe<UserEstablishmentWhereInput[] | UserEstablishmentWhereInput>;
  OR?: Maybe<UserEstablishmentWhereInput[] | UserEstablishmentWhereInput>;
  NOT?: Maybe<UserEstablishmentWhereInput[] | UserEstablishmentWhereInput>;
}

export type AppointmentStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DayWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type EstablishmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type HourWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type TypeOfShiftWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
}>;

export type UserEstablishmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AppointmentCreateInput {
  id?: Maybe<Int>;
  appointmentStatus?: Maybe<AppointmentStatusCreateOneWithoutAppointmentInput>;
  client?: Maybe<UserCreateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentStatusCreateOneWithoutAppointmentInput {
  create?: Maybe<AppointmentStatusCreateWithoutAppointmentInput>;
  connect?: Maybe<AppointmentStatusWhereUniqueInput>;
}

export interface AppointmentStatusCreateWithoutAppointmentInput {
  id?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface UserCreateOneWithoutAppointmentInput {
  create?: Maybe<UserCreateWithoutAppointmentInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutAppointmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface DepartmentCreateOneWithoutUserInput {
  create?: Maybe<DepartmentCreateWithoutUserInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutUserInput {
  id?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  establishment?: Maybe<EstablishmentCreateManyWithoutDepartmentInput>;
  name?: Maybe<String>;
}

export interface EstablishmentCreateManyWithoutDepartmentInput {
  create?: Maybe<
    | EstablishmentCreateWithoutDepartmentInput[]
    | EstablishmentCreateWithoutDepartmentInput
  >;
  connect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
}

export interface EstablishmentCreateWithoutDepartmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface AppointmentCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | AppointmentCreateWithoutEstablishmentInput[]
    | AppointmentCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
}

export interface AppointmentCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  appointmentStatus?: Maybe<AppointmentStatusCreateOneWithoutAppointmentInput>;
  client?: Maybe<UserCreateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface HourCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    HourCreateWithoutEstablishmentInput[] | HourCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
}

export interface HourCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  day?: Maybe<DayCreateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftCreateOneWithoutHoursInput>;
}

export interface DayCreateOneWithoutHoursInput {
  create?: Maybe<DayCreateWithoutHoursInput>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface DayCreateWithoutHoursInput {
  id?: Maybe<Int>;
  name: String;
}

export interface TypeOfShiftCreateOneWithoutHoursInput {
  create?: Maybe<TypeOfShiftCreateWithoutHoursInput>;
  connect?: Maybe<TypeOfShiftWhereUniqueInput>;
}

export interface TypeOfShiftCreateWithoutHoursInput {
  id?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface UserCreateOneWithoutEstablishmentInput {
  create?: Maybe<UserCreateWithoutEstablishmentInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface AppointmentCreateManyWithoutClientInput {
  create?: Maybe<
    AppointmentCreateWithoutClientInput[] | AppointmentCreateWithoutClientInput
  >;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
}

export interface AppointmentCreateWithoutClientInput {
  id?: Maybe<Int>;
  appointmentStatus?: Maybe<AppointmentStatusCreateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface EstablishmentCreateOneWithoutAppointmentInput {
  create?: Maybe<EstablishmentCreateWithoutAppointmentInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutAppointmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface DepartmentCreateOneWithoutEstablishmentInput {
  create?: Maybe<DepartmentCreateWithoutEstablishmentInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
  user?: Maybe<UserCreateManyWithoutDepartmentInput>;
}

export interface UserCreateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutDepartmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface EstablishmentCreateManyWithoutOwnerInput {
  create?: Maybe<
    | EstablishmentCreateWithoutOwnerInput[]
    | EstablishmentCreateWithoutOwnerInput
  >;
  connect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
}

export interface EstablishmentCreateWithoutOwnerInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ReportCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ReportCreateWithoutEstablishmentInput[]
    | ReportCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  author?: Maybe<UserCreateOneWithoutReportInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface UserCreateOneWithoutReportInput {
  create?: Maybe<UserCreateWithoutReportInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutReportInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface ReviewCreateManyWithoutAuthorInput {
  create?: Maybe<
    ReviewCreateWithoutAuthorInput[] | ReviewCreateWithoutAuthorInput
  >;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface ReviewCreateWithoutAuthorInput {
  id?: Maybe<Int>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutReviewInput>;
  mark?: Maybe<Int>;
}

export interface EstablishmentCreateOneWithoutReviewInput {
  create?: Maybe<EstablishmentCreateWithoutReviewInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutReviewInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ServiceCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ServiceCreateWithoutEstablishmentInput[]
    | ServiceCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  createdBy?: Maybe<UserCreateOneInput>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  updatedBy?: Maybe<UserCreateOneInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface ReportCreateManyWithoutAuthorInput {
  create?: Maybe<
    ReportCreateWithoutAuthorInput[] | ReportCreateWithoutAuthorInput
  >;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutAuthorInput {
  id?: Maybe<Int>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutReportInput>;
  title?: Maybe<String>;
}

export interface EstablishmentCreateOneWithoutReportInput {
  create?: Maybe<EstablishmentCreateWithoutReportInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutReportInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ReviewCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ReviewCreateWithoutEstablishmentInput[]
    | ReviewCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface ReviewCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  author?: Maybe<UserCreateOneWithoutReviewInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface UserCreateOneWithoutReviewInput {
  create?: Maybe<UserCreateWithoutReviewInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutReviewInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  roles: Json;
  userEstablishment?: Maybe<UserEstablishmentCreateManyWithoutManagerInput>;
}

export interface UserEstablishmentCreateManyWithoutManagerInput {
  create?: Maybe<
    | UserEstablishmentCreateWithoutManagerInput[]
    | UserEstablishmentCreateWithoutManagerInput
  >;
  connect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
}

export interface UserEstablishmentCreateWithoutManagerInput {
  id?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface EstablishmentCreateOneWithoutUserEstablishmentInput {
  create?: Maybe<EstablishmentCreateWithoutUserEstablishmentInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutUserEstablishmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface UserEstablishmentCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | UserEstablishmentCreateWithoutEstablishmentInput[]
    | UserEstablishmentCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
}

export interface UserEstablishmentCreateWithoutEstablishmentInput {
  id?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  manager?: Maybe<UserCreateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutUserEstablishmentInput {
  create?: Maybe<UserCreateWithoutUserEstablishmentInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutUserEstablishmentInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentCreateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutUserInput>;
  email: String;
  establishment?: Maybe<EstablishmentCreateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password: String;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutAuthorInput>;
  review?: Maybe<ReviewCreateManyWithoutAuthorInput>;
  roles: Json;
}

export interface AppointmentUpdateInput {
  appointmentStatus?: Maybe<AppointmentStatusUpdateOneWithoutAppointmentInput>;
  client?: Maybe<UserUpdateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentStatusUpdateOneWithoutAppointmentInput {
  create?: Maybe<AppointmentStatusCreateWithoutAppointmentInput>;
  update?: Maybe<AppointmentStatusUpdateWithoutAppointmentDataInput>;
  upsert?: Maybe<AppointmentStatusUpsertWithoutAppointmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AppointmentStatusWhereUniqueInput>;
}

export interface AppointmentStatusUpdateWithoutAppointmentDataInput {
  name?: Maybe<String>;
}

export interface AppointmentStatusUpsertWithoutAppointmentInput {
  update: AppointmentStatusUpdateWithoutAppointmentDataInput;
  create: AppointmentStatusCreateWithoutAppointmentInput;
}

export interface UserUpdateOneWithoutAppointmentInput {
  create?: Maybe<UserCreateWithoutAppointmentInput>;
  update?: Maybe<UserUpdateWithoutAppointmentDataInput>;
  upsert?: Maybe<UserUpsertWithoutAppointmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutAppointmentDataInput {
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface DepartmentUpdateOneWithoutUserInput {
  create?: Maybe<DepartmentCreateWithoutUserInput>;
  update?: Maybe<DepartmentUpdateWithoutUserDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutUserDataInput {
  departmentCode?: Maybe<Int>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutDepartmentInput>;
  name?: Maybe<String>;
}

export interface EstablishmentUpdateManyWithoutDepartmentInput {
  create?: Maybe<
    | EstablishmentCreateWithoutDepartmentInput[]
    | EstablishmentCreateWithoutDepartmentInput
  >;
  delete?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  connect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  set?: Maybe<EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput>;
  disconnect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  update?: Maybe<
    | EstablishmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    | EstablishmentUpdateWithWhereUniqueWithoutDepartmentInput
  >;
  upsert?: Maybe<
    | EstablishmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    | EstablishmentUpsertWithWhereUniqueWithoutDepartmentInput
  >;
  deleteMany?: Maybe<
    EstablishmentScalarWhereInput[] | EstablishmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | EstablishmentUpdateManyWithWhereNestedInput[]
    | EstablishmentUpdateManyWithWhereNestedInput
  >;
}

export interface EstablishmentUpdateWithWhereUniqueWithoutDepartmentInput {
  where: EstablishmentWhereUniqueInput;
  data: EstablishmentUpdateWithoutDepartmentDataInput;
}

export interface EstablishmentUpdateWithoutDepartmentDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface AppointmentUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | AppointmentCreateWithoutEstablishmentInput[]
    | AppointmentCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  set?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  disconnect?: Maybe<
    AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput
  >;
  update?: Maybe<
    | AppointmentUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | AppointmentUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | AppointmentUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | AppointmentUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<
    AppointmentScalarWhereInput[] | AppointmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | AppointmentUpdateManyWithWhereNestedInput[]
    | AppointmentUpdateManyWithWhereNestedInput
  >;
}

export interface AppointmentUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: AppointmentWhereUniqueInput;
  data: AppointmentUpdateWithoutEstablishmentDataInput;
}

export interface AppointmentUpdateWithoutEstablishmentDataInput {
  appointmentStatus?: Maybe<AppointmentStatusUpdateOneWithoutAppointmentInput>;
  client?: Maybe<UserUpdateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: AppointmentWhereUniqueInput;
  update: AppointmentUpdateWithoutEstablishmentDataInput;
  create: AppointmentCreateWithoutEstablishmentInput;
}

export interface AppointmentScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AppointmentScalarWhereInput[] | AppointmentScalarWhereInput>;
  OR?: Maybe<AppointmentScalarWhereInput[] | AppointmentScalarWhereInput>;
  NOT?: Maybe<AppointmentScalarWhereInput[] | AppointmentScalarWhereInput>;
}

export interface AppointmentUpdateManyWithWhereNestedInput {
  where: AppointmentScalarWhereInput;
  data: AppointmentUpdateManyDataInput;
}

export interface AppointmentUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface HourUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    HourCreateWithoutEstablishmentInput[] | HourCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  set?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  disconnect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  update?: Maybe<
    | HourUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | HourUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | HourUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | HourUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface HourUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: HourWhereUniqueInput;
  data: HourUpdateWithoutEstablishmentDataInput;
}

export interface HourUpdateWithoutEstablishmentDataInput {
  active?: Maybe<Boolean>;
  day?: Maybe<DayUpdateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftUpdateOneWithoutHoursInput>;
}

export interface DayUpdateOneWithoutHoursInput {
  create?: Maybe<DayCreateWithoutHoursInput>;
  update?: Maybe<DayUpdateWithoutHoursDataInput>;
  upsert?: Maybe<DayUpsertWithoutHoursInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface DayUpdateWithoutHoursDataInput {
  name?: Maybe<String>;
}

export interface DayUpsertWithoutHoursInput {
  update: DayUpdateWithoutHoursDataInput;
  create: DayCreateWithoutHoursInput;
}

export interface TypeOfShiftUpdateOneWithoutHoursInput {
  create?: Maybe<TypeOfShiftCreateWithoutHoursInput>;
  update?: Maybe<TypeOfShiftUpdateWithoutHoursDataInput>;
  upsert?: Maybe<TypeOfShiftUpsertWithoutHoursInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TypeOfShiftWhereUniqueInput>;
}

export interface TypeOfShiftUpdateWithoutHoursDataInput {
  name?: Maybe<String>;
}

export interface TypeOfShiftUpsertWithoutHoursInput {
  update: TypeOfShiftUpdateWithoutHoursDataInput;
  create: TypeOfShiftCreateWithoutHoursInput;
}

export interface HourUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: HourWhereUniqueInput;
  update: HourUpdateWithoutEstablishmentDataInput;
  create: HourCreateWithoutEstablishmentInput;
}

export interface HourScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  endHour_not?: Maybe<DateTimeInput>;
  endHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endHour_lt?: Maybe<DateTimeInput>;
  endHour_lte?: Maybe<DateTimeInput>;
  endHour_gt?: Maybe<DateTimeInput>;
  endHour_gte?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  nbBarber_not?: Maybe<Int>;
  nbBarber_in?: Maybe<Int[] | Int>;
  nbBarber_not_in?: Maybe<Int[] | Int>;
  nbBarber_lt?: Maybe<Int>;
  nbBarber_lte?: Maybe<Int>;
  nbBarber_gt?: Maybe<Int>;
  nbBarber_gte?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  startHour_not?: Maybe<DateTimeInput>;
  startHour_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startHour_lt?: Maybe<DateTimeInput>;
  startHour_lte?: Maybe<DateTimeInput>;
  startHour_gt?: Maybe<DateTimeInput>;
  startHour_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  OR?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  NOT?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
}

export interface HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput;
  data: HourUpdateManyDataInput;
}

export interface HourUpdateManyDataInput {
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneWithoutEstablishmentInput {
  create?: Maybe<UserCreateWithoutEstablishmentInput>;
  update?: Maybe<UserUpdateWithoutEstablishmentDataInput>;
  upsert?: Maybe<UserUpsertWithoutEstablishmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEstablishmentDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface AppointmentUpdateManyWithoutClientInput {
  create?: Maybe<
    AppointmentCreateWithoutClientInput[] | AppointmentCreateWithoutClientInput
  >;
  delete?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  set?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  disconnect?: Maybe<
    AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput
  >;
  update?: Maybe<
    | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    | AppointmentUpdateWithWhereUniqueWithoutClientInput
  >;
  upsert?: Maybe<
    | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    | AppointmentUpsertWithWhereUniqueWithoutClientInput
  >;
  deleteMany?: Maybe<
    AppointmentScalarWhereInput[] | AppointmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | AppointmentUpdateManyWithWhereNestedInput[]
    | AppointmentUpdateManyWithWhereNestedInput
  >;
}

export interface AppointmentUpdateWithWhereUniqueWithoutClientInput {
  where: AppointmentWhereUniqueInput;
  data: AppointmentUpdateWithoutClientDataInput;
}

export interface AppointmentUpdateWithoutClientDataInput {
  appointmentStatus?: Maybe<AppointmentStatusUpdateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface EstablishmentUpdateOneWithoutAppointmentInput {
  create?: Maybe<EstablishmentCreateWithoutAppointmentInput>;
  update?: Maybe<EstablishmentUpdateWithoutAppointmentDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutAppointmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutAppointmentDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface DepartmentUpdateOneWithoutEstablishmentInput {
  create?: Maybe<DepartmentCreateWithoutEstablishmentInput>;
  update?: Maybe<DepartmentUpdateWithoutEstablishmentDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutEstablishmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutEstablishmentDataInput {
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
  user?: Maybe<UserUpdateManyWithoutDepartmentInput>;
}

export interface UserUpdateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    | UserUpdateWithWhereUniqueWithoutDepartmentInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    | UserUpsertWithWhereUniqueWithoutDepartmentInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDepartmentDataInput;
}

export interface UserUpdateWithoutDepartmentDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface EstablishmentUpdateManyWithoutOwnerInput {
  create?: Maybe<
    | EstablishmentCreateWithoutOwnerInput[]
    | EstablishmentCreateWithoutOwnerInput
  >;
  delete?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  connect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  set?: Maybe<EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput>;
  disconnect?: Maybe<
    EstablishmentWhereUniqueInput[] | EstablishmentWhereUniqueInput
  >;
  update?: Maybe<
    | EstablishmentUpdateWithWhereUniqueWithoutOwnerInput[]
    | EstablishmentUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | EstablishmentUpsertWithWhereUniqueWithoutOwnerInput[]
    | EstablishmentUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<
    EstablishmentScalarWhereInput[] | EstablishmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | EstablishmentUpdateManyWithWhereNestedInput[]
    | EstablishmentUpdateManyWithWhereNestedInput
  >;
}

export interface EstablishmentUpdateWithWhereUniqueWithoutOwnerInput {
  where: EstablishmentWhereUniqueInput;
  data: EstablishmentUpdateWithoutOwnerDataInput;
}

export interface EstablishmentUpdateWithoutOwnerDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ReportUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ReportCreateWithoutEstablishmentInput[]
    | ReportCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ReportUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ReportUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export interface ReportUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutEstablishmentDataInput;
}

export interface ReportUpdateWithoutEstablishmentDataInput {
  author?: Maybe<UserUpdateOneWithoutReportInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface UserUpdateOneWithoutReportInput {
  create?: Maybe<UserCreateWithoutReportInput>;
  update?: Maybe<UserUpdateWithoutReportDataInput>;
  upsert?: Maybe<UserUpsertWithoutReportInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReportDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface ReviewUpdateManyWithoutAuthorInput {
  create?: Maybe<
    ReviewCreateWithoutAuthorInput[] | ReviewCreateWithoutAuthorInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    | ReviewUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    | ReviewUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface ReviewUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutAuthorDataInput;
}

export interface ReviewUpdateWithoutAuthorDataInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutReviewInput>;
  mark?: Maybe<Int>;
}

export interface EstablishmentUpdateOneWithoutReviewInput {
  create?: Maybe<EstablishmentCreateWithoutReviewInput>;
  update?: Maybe<EstablishmentUpdateWithoutReviewDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutReviewInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutReviewDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ServiceUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ServiceCreateWithoutEstablishmentInput[]
    | ServiceCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ServiceUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ServiceUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  updateMany?: Maybe<
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ServiceUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutEstablishmentDataInput;
}

export interface ServiceUpdateWithoutEstablishmentDataInput {
  active?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneInput>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  updatedBy?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface ReportUpdateManyWithoutAuthorInput {
  create?: Maybe<
    ReportCreateWithoutAuthorInput[] | ReportCreateWithoutAuthorInput
  >;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutAuthorInput[]
    | ReportUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutAuthorInput[]
    | ReportUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export interface ReportUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutAuthorDataInput;
}

export interface ReportUpdateWithoutAuthorDataInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutReportInput>;
  title?: Maybe<String>;
}

export interface EstablishmentUpdateOneWithoutReportInput {
  create?: Maybe<EstablishmentCreateWithoutReportInput>;
  update?: Maybe<EstablishmentUpdateWithoutReportDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutReportInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutReportDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ReviewUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ReviewCreateWithoutEstablishmentInput[]
    | ReviewCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ReviewUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ReviewUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface ReviewUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutEstablishmentDataInput;
}

export interface ReviewUpdateWithoutEstablishmentDataInput {
  author?: Maybe<UserUpdateOneWithoutReviewInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface UserUpdateOneWithoutReviewInput {
  create?: Maybe<UserCreateWithoutReviewInput>;
  update?: Maybe<UserUpdateWithoutReviewDataInput>;
  upsert?: Maybe<UserUpsertWithoutReviewInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReviewDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface UserEstablishmentUpdateManyWithoutManagerInput {
  create?: Maybe<
    | UserEstablishmentCreateWithoutManagerInput[]
    | UserEstablishmentCreateWithoutManagerInput
  >;
  delete?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  connect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  set?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  update?: Maybe<
    | UserEstablishmentUpdateWithWhereUniqueWithoutManagerInput[]
    | UserEstablishmentUpdateWithWhereUniqueWithoutManagerInput
  >;
  upsert?: Maybe<
    | UserEstablishmentUpsertWithWhereUniqueWithoutManagerInput[]
    | UserEstablishmentUpsertWithWhereUniqueWithoutManagerInput
  >;
  deleteMany?: Maybe<
    UserEstablishmentScalarWhereInput[] | UserEstablishmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserEstablishmentUpdateManyWithWhereNestedInput[]
    | UserEstablishmentUpdateManyWithWhereNestedInput
  >;
}

export interface UserEstablishmentUpdateWithWhereUniqueWithoutManagerInput {
  where: UserEstablishmentWhereUniqueInput;
  data: UserEstablishmentUpdateWithoutManagerDataInput;
}

export interface UserEstablishmentUpdateWithoutManagerDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface EstablishmentUpdateOneWithoutUserEstablishmentInput {
  create?: Maybe<EstablishmentCreateWithoutUserEstablishmentInput>;
  update?: Maybe<EstablishmentUpdateWithoutUserEstablishmentDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutUserEstablishmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutUserEstablishmentDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface EstablishmentUpsertWithoutUserEstablishmentInput {
  update: EstablishmentUpdateWithoutUserEstablishmentDataInput;
  create: EstablishmentCreateWithoutUserEstablishmentInput;
}

export interface UserEstablishmentUpsertWithWhereUniqueWithoutManagerInput {
  where: UserEstablishmentWhereUniqueInput;
  update: UserEstablishmentUpdateWithoutManagerDataInput;
  create: UserEstablishmentCreateWithoutManagerInput;
}

export interface UserEstablishmentScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
  validated_not?: Maybe<Boolean>;
  AND?: Maybe<
    UserEstablishmentScalarWhereInput[] | UserEstablishmentScalarWhereInput
  >;
  OR?: Maybe<
    UserEstablishmentScalarWhereInput[] | UserEstablishmentScalarWhereInput
  >;
  NOT?: Maybe<
    UserEstablishmentScalarWhereInput[] | UserEstablishmentScalarWhereInput
  >;
}

export interface UserEstablishmentUpdateManyWithWhereNestedInput {
  where: UserEstablishmentScalarWhereInput;
  data: UserEstablishmentUpdateManyDataInput;
}

export interface UserEstablishmentUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
}

export interface UserUpsertWithoutReviewInput {
  update: UserUpdateWithoutReviewDataInput;
  create: UserCreateWithoutReviewInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutEstablishmentDataInput;
  create: ReviewCreateWithoutEstablishmentInput;
}

export interface ReviewScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
  mark_not?: Maybe<Int>;
  mark_in?: Maybe<Int[] | Int>;
  mark_not_in?: Maybe<Int[] | Int>;
  mark_lt?: Maybe<Int>;
  mark_lte?: Maybe<Int>;
  mark_gt?: Maybe<Int>;
  mark_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  OR?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  NOT?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface ReviewUpdateManyDataInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface UserEstablishmentUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | UserEstablishmentCreateWithoutEstablishmentInput[]
    | UserEstablishmentCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  connect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  set?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserEstablishmentWhereUniqueInput[] | UserEstablishmentWhereUniqueInput
  >;
  update?: Maybe<
    | UserEstablishmentUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | UserEstablishmentUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | UserEstablishmentUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | UserEstablishmentUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<
    UserEstablishmentScalarWhereInput[] | UserEstablishmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserEstablishmentUpdateManyWithWhereNestedInput[]
    | UserEstablishmentUpdateManyWithWhereNestedInput
  >;
}

export interface UserEstablishmentUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: UserEstablishmentWhereUniqueInput;
  data: UserEstablishmentUpdateWithoutEstablishmentDataInput;
}

export interface UserEstablishmentUpdateWithoutEstablishmentDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  manager?: Maybe<UserUpdateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface UserUpdateOneWithoutUserEstablishmentInput {
  create?: Maybe<UserCreateWithoutUserEstablishmentInput>;
  update?: Maybe<UserUpdateWithoutUserEstablishmentDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserEstablishmentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutUserEstablishmentDataInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
}

export interface UserUpsertWithoutUserEstablishmentInput {
  update: UserUpdateWithoutUserEstablishmentDataInput;
  create: UserCreateWithoutUserEstablishmentInput;
}

export interface UserEstablishmentUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: UserEstablishmentWhereUniqueInput;
  update: UserEstablishmentUpdateWithoutEstablishmentDataInput;
  create: UserEstablishmentCreateWithoutEstablishmentInput;
}

export interface EstablishmentUpsertWithoutReportInput {
  update: EstablishmentUpdateWithoutReportDataInput;
  create: EstablishmentCreateWithoutReportInput;
}

export interface ReportUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutAuthorDataInput;
  create: ReportCreateWithoutAuthorInput;
}

export interface ReportScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  OR?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  NOT?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
}

export interface ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput;
  data: ReportUpdateManyDataInput;
}

export interface ReportUpdateManyDataInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ServiceUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutEstablishmentDataInput;
  create: ServiceCreateWithoutEstablishmentInput;
}

export interface ServiceScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  OR?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  NOT?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
}

export interface ServiceUpdateManyWithWhereNestedInput {
  where: ServiceScalarWhereInput;
  data: ServiceUpdateManyDataInput;
}

export interface ServiceUpdateManyDataInput {
  active?: Maybe<Boolean>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
}

export interface EstablishmentUpsertWithoutReviewInput {
  update: EstablishmentUpdateWithoutReviewDataInput;
  create: EstablishmentCreateWithoutReviewInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutAuthorDataInput;
  create: ReviewCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutReportInput {
  update: UserUpdateWithoutReportDataInput;
  create: UserCreateWithoutReportInput;
}

export interface ReportUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutEstablishmentDataInput;
  create: ReportCreateWithoutEstablishmentInput;
}

export interface EstablishmentUpsertWithWhereUniqueWithoutOwnerInput {
  where: EstablishmentWhereUniqueInput;
  update: EstablishmentUpdateWithoutOwnerDataInput;
  create: EstablishmentCreateWithoutOwnerInput;
}

export interface EstablishmentScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  addressComplement?: Maybe<String>;
  addressComplement_not?: Maybe<String>;
  addressComplement_in?: Maybe<String[] | String>;
  addressComplement_not_in?: Maybe<String[] | String>;
  addressComplement_lt?: Maybe<String>;
  addressComplement_lte?: Maybe<String>;
  addressComplement_gt?: Maybe<String>;
  addressComplement_gte?: Maybe<String>;
  addressComplement_contains?: Maybe<String>;
  addressComplement_not_contains?: Maybe<String>;
  addressComplement_starts_with?: Maybe<String>;
  addressComplement_not_starts_with?: Maybe<String>;
  addressComplement_ends_with?: Maybe<String>;
  addressComplement_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  commercialName?: Maybe<String>;
  commercialName_not?: Maybe<String>;
  commercialName_in?: Maybe<String[] | String>;
  commercialName_not_in?: Maybe<String[] | String>;
  commercialName_lt?: Maybe<String>;
  commercialName_lte?: Maybe<String>;
  commercialName_gt?: Maybe<String>;
  commercialName_gte?: Maybe<String>;
  commercialName_contains?: Maybe<String>;
  commercialName_not_contains?: Maybe<String>;
  commercialName_starts_with?: Maybe<String>;
  commercialName_not_starts_with?: Maybe<String>;
  commercialName_ends_with?: Maybe<String>;
  commercialName_not_ends_with?: Maybe<String>;
  contactEmail?: Maybe<String>;
  contactEmail_not?: Maybe<String>;
  contactEmail_in?: Maybe<String[] | String>;
  contactEmail_not_in?: Maybe<String[] | String>;
  contactEmail_lt?: Maybe<String>;
  contactEmail_lte?: Maybe<String>;
  contactEmail_gt?: Maybe<String>;
  contactEmail_gte?: Maybe<String>;
  contactEmail_contains?: Maybe<String>;
  contactEmail_not_contains?: Maybe<String>;
  contactEmail_starts_with?: Maybe<String>;
  contactEmail_not_starts_with?: Maybe<String>;
  contactEmail_ends_with?: Maybe<String>;
  contactEmail_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  illustration?: Maybe<String>;
  illustration_not?: Maybe<String>;
  illustration_in?: Maybe<String[] | String>;
  illustration_not_in?: Maybe<String[] | String>;
  illustration_lt?: Maybe<String>;
  illustration_lte?: Maybe<String>;
  illustration_gt?: Maybe<String>;
  illustration_gte?: Maybe<String>;
  illustration_contains?: Maybe<String>;
  illustration_not_contains?: Maybe<String>;
  illustration_starts_with?: Maybe<String>;
  illustration_not_starts_with?: Maybe<String>;
  illustration_ends_with?: Maybe<String>;
  illustration_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  siret?: Maybe<String>;
  siret_not?: Maybe<String>;
  siret_in?: Maybe<String[] | String>;
  siret_not_in?: Maybe<String[] | String>;
  siret_lt?: Maybe<String>;
  siret_lte?: Maybe<String>;
  siret_gt?: Maybe<String>;
  siret_gte?: Maybe<String>;
  siret_contains?: Maybe<String>;
  siret_not_contains?: Maybe<String>;
  siret_starts_with?: Maybe<String>;
  siret_not_starts_with?: Maybe<String>;
  siret_ends_with?: Maybe<String>;
  siret_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<EstablishmentScalarWhereInput[] | EstablishmentScalarWhereInput>;
  OR?: Maybe<EstablishmentScalarWhereInput[] | EstablishmentScalarWhereInput>;
  NOT?: Maybe<EstablishmentScalarWhereInput[] | EstablishmentScalarWhereInput>;
}

export interface EstablishmentUpdateManyWithWhereNestedInput {
  where: EstablishmentScalarWhereInput;
  data: EstablishmentUpdateManyDataInput;
}

export interface EstablishmentUpdateManyDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDepartmentDataInput;
  create: UserCreateWithoutDepartmentInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  birthdate_not?: Maybe<DateTimeInput>;
  birthdate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_lt?: Maybe<DateTimeInput>;
  birthdate_lte?: Maybe<DateTimeInput>;
  birthdate_gt?: Maybe<DateTimeInput>;
  birthdate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  roles?: Maybe<Json>;
}

export interface DepartmentUpsertWithoutEstablishmentInput {
  update: DepartmentUpdateWithoutEstablishmentDataInput;
  create: DepartmentCreateWithoutEstablishmentInput;
}

export interface EstablishmentUpsertWithoutAppointmentInput {
  update: EstablishmentUpdateWithoutAppointmentDataInput;
  create: EstablishmentCreateWithoutAppointmentInput;
}

export interface AppointmentUpsertWithWhereUniqueWithoutClientInput {
  where: AppointmentWhereUniqueInput;
  update: AppointmentUpdateWithoutClientDataInput;
  create: AppointmentCreateWithoutClientInput;
}

export interface UserUpsertWithoutEstablishmentInput {
  update: UserUpdateWithoutEstablishmentDataInput;
  create: UserCreateWithoutEstablishmentInput;
}

export interface EstablishmentUpsertWithWhereUniqueWithoutDepartmentInput {
  where: EstablishmentWhereUniqueInput;
  update: EstablishmentUpdateWithoutDepartmentDataInput;
  create: EstablishmentCreateWithoutDepartmentInput;
}

export interface DepartmentUpsertWithoutUserInput {
  update: DepartmentUpdateWithoutUserDataInput;
  create: DepartmentCreateWithoutUserInput;
}

export interface UserUpsertWithoutAppointmentInput {
  update: UserUpdateWithoutAppointmentDataInput;
  create: UserCreateWithoutAppointmentInput;
}

export interface AppointmentUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentStatusCreateInput {
  id?: Maybe<Int>;
  appointment?: Maybe<AppointmentCreateManyWithoutAppointmentStatusInput>;
  name?: Maybe<String>;
}

export interface AppointmentCreateManyWithoutAppointmentStatusInput {
  create?: Maybe<
    | AppointmentCreateWithoutAppointmentStatusInput[]
    | AppointmentCreateWithoutAppointmentStatusInput
  >;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
}

export interface AppointmentCreateWithoutAppointmentStatusInput {
  id?: Maybe<Int>;
  client?: Maybe<UserCreateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentStatusUpdateInput {
  appointment?: Maybe<AppointmentUpdateManyWithoutAppointmentStatusInput>;
  name?: Maybe<String>;
}

export interface AppointmentUpdateManyWithoutAppointmentStatusInput {
  create?: Maybe<
    | AppointmentCreateWithoutAppointmentStatusInput[]
    | AppointmentCreateWithoutAppointmentStatusInput
  >;
  delete?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  connect?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  set?: Maybe<AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput>;
  disconnect?: Maybe<
    AppointmentWhereUniqueInput[] | AppointmentWhereUniqueInput
  >;
  update?: Maybe<
    | AppointmentUpdateWithWhereUniqueWithoutAppointmentStatusInput[]
    | AppointmentUpdateWithWhereUniqueWithoutAppointmentStatusInput
  >;
  upsert?: Maybe<
    | AppointmentUpsertWithWhereUniqueWithoutAppointmentStatusInput[]
    | AppointmentUpsertWithWhereUniqueWithoutAppointmentStatusInput
  >;
  deleteMany?: Maybe<
    AppointmentScalarWhereInput[] | AppointmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | AppointmentUpdateManyWithWhereNestedInput[]
    | AppointmentUpdateManyWithWhereNestedInput
  >;
}

export interface AppointmentUpdateWithWhereUniqueWithoutAppointmentStatusInput {
  where: AppointmentWhereUniqueInput;
  data: AppointmentUpdateWithoutAppointmentStatusDataInput;
}

export interface AppointmentUpdateWithoutAppointmentStatusDataInput {
  client?: Maybe<UserUpdateOneWithoutAppointmentInput>;
  deletedAt?: Maybe<DateTimeInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutAppointmentInput>;
  startHour?: Maybe<DateTimeInput>;
}

export interface AppointmentUpsertWithWhereUniqueWithoutAppointmentStatusInput {
  where: AppointmentWhereUniqueInput;
  update: AppointmentUpdateWithoutAppointmentStatusDataInput;
  create: AppointmentCreateWithoutAppointmentStatusInput;
}

export interface AppointmentStatusUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface DayCreateInput {
  id?: Maybe<Int>;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
  name: String;
}

export interface HourCreateManyWithoutDayInput {
  create?: Maybe<HourCreateWithoutDayInput[] | HourCreateWithoutDayInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
}

export interface HourCreateWithoutDayInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftCreateOneWithoutHoursInput>;
}

export interface EstablishmentCreateOneWithoutHoursInput {
  create?: Maybe<EstablishmentCreateWithoutHoursInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutHoursInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface DayUpdateInput {
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
  name?: Maybe<String>;
}

export interface HourUpdateManyWithoutDayInput {
  create?: Maybe<HourCreateWithoutDayInput[] | HourCreateWithoutDayInput>;
  delete?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  set?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  disconnect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  update?: Maybe<
    | HourUpdateWithWhereUniqueWithoutDayInput[]
    | HourUpdateWithWhereUniqueWithoutDayInput
  >;
  upsert?: Maybe<
    | HourUpsertWithWhereUniqueWithoutDayInput[]
    | HourUpsertWithWhereUniqueWithoutDayInput
  >;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface HourUpdateWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput;
  data: HourUpdateWithoutDayDataInput;
}

export interface HourUpdateWithoutDayDataInput {
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftUpdateOneWithoutHoursInput>;
}

export interface EstablishmentUpdateOneWithoutHoursInput {
  create?: Maybe<EstablishmentCreateWithoutHoursInput>;
  update?: Maybe<EstablishmentUpdateWithoutHoursDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutHoursInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutHoursDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface EstablishmentUpsertWithoutHoursInput {
  update: EstablishmentUpdateWithoutHoursDataInput;
  create: EstablishmentCreateWithoutHoursInput;
}

export interface HourUpsertWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput;
  update: HourUpdateWithoutDayDataInput;
  create: HourCreateWithoutDayInput;
}

export interface DayUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface DepartmentCreateInput {
  id?: Maybe<Int>;
  departmentCode?: Maybe<Int>;
  establishment?: Maybe<EstablishmentCreateManyWithoutDepartmentInput>;
  name?: Maybe<String>;
  user?: Maybe<UserCreateManyWithoutDepartmentInput>;
}

export interface DepartmentUpdateInput {
  departmentCode?: Maybe<Int>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutDepartmentInput>;
  name?: Maybe<String>;
  user?: Maybe<UserUpdateManyWithoutDepartmentInput>;
}

export interface DepartmentUpdateManyMutationInput {
  departmentCode?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface EstablishmentCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface EstablishmentUpdateInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  service?: Maybe<ServiceUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface EstablishmentUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  siret?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface HourCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  day?: Maybe<DayCreateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftCreateOneWithoutHoursInput>;
}

export interface HourUpdateInput {
  active?: Maybe<Boolean>;
  day?: Maybe<DayUpdateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
  typeOfShift?: Maybe<TypeOfShiftUpdateOneWithoutHoursInput>;
}

export interface HourUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  endHour?: Maybe<DateTimeInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface ReportCreateInput {
  id?: Maybe<Int>;
  author?: Maybe<UserCreateOneWithoutReportInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutReportInput>;
  title?: Maybe<String>;
}

export interface ReportUpdateInput {
  author?: Maybe<UserUpdateOneWithoutReportInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutReportInput>;
  title?: Maybe<String>;
}

export interface ReportUpdateManyMutationInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
}

export interface ReviewCreateInput {
  id?: Maybe<Int>;
  author?: Maybe<UserCreateOneWithoutReviewInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutReviewInput>;
  mark?: Maybe<Int>;
}

export interface ReviewUpdateInput {
  author?: Maybe<UserUpdateOneWithoutReviewInput>;
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutReviewInput>;
  mark?: Maybe<Int>;
}

export interface ReviewUpdateManyMutationInput {
  content?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  mark?: Maybe<Int>;
}

export interface ServiceCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  createdBy?: Maybe<UserCreateOneInput>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  establishment?: Maybe<EstablishmentCreateOneWithoutServiceInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  updatedBy?: Maybe<UserCreateOneInput>;
}

export interface EstablishmentCreateOneWithoutServiceInput {
  create?: Maybe<EstablishmentCreateWithoutServiceInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutServiceInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentCreateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentCreateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserCreateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportCreateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewCreateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentCreateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface ServiceUpdateInput {
  active?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneInput>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutServiceInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  updatedBy?: Maybe<UserUpdateOneInput>;
}

export interface EstablishmentUpdateOneWithoutServiceInput {
  create?: Maybe<EstablishmentCreateWithoutServiceInput>;
  update?: Maybe<EstablishmentUpdateWithoutServiceDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutServiceInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutServiceDataInput {
  active?: Maybe<Boolean>;
  address?: Maybe<String>;
  addressComplement?: Maybe<String>;
  appointment?: Maybe<AppointmentUpdateManyWithoutEstablishmentInput>;
  city?: Maybe<String>;
  commercialName?: Maybe<String>;
  contactEmail?: Maybe<String>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutEstablishmentInput>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyWithoutEstablishmentInput>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneWithoutEstablishmentInput>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutEstablishmentInput>;
  review?: Maybe<ReviewUpdateManyWithoutEstablishmentInput>;
  siret?: Maybe<String>;
  userEstablishment?: Maybe<
    UserEstablishmentUpdateManyWithoutEstablishmentInput
  >;
  zipCode?: Maybe<String>;
}

export interface EstablishmentUpsertWithoutServiceInput {
  update: EstablishmentUpdateWithoutServiceDataInput;
  create: EstablishmentCreateWithoutServiceInput;
}

export interface ServiceUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  deletedAt?: Maybe<DateTimeInput>;
  duration?: Maybe<Int>;
  illustration?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
}

export interface TypeOfShiftCreateInput {
  id?: Maybe<Int>;
  hours?: Maybe<HourCreateManyWithoutTypeOfShiftInput>;
  name?: Maybe<String>;
}

export interface HourCreateManyWithoutTypeOfShiftInput {
  create?: Maybe<
    HourCreateWithoutTypeOfShiftInput[] | HourCreateWithoutTypeOfShiftInput
  >;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
}

export interface HourCreateWithoutTypeOfShiftInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  day?: Maybe<DayCreateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface TypeOfShiftUpdateInput {
  hours?: Maybe<HourUpdateManyWithoutTypeOfShiftInput>;
  name?: Maybe<String>;
}

export interface HourUpdateManyWithoutTypeOfShiftInput {
  create?: Maybe<
    HourCreateWithoutTypeOfShiftInput[] | HourCreateWithoutTypeOfShiftInput
  >;
  delete?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  set?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  disconnect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  update?: Maybe<
    | HourUpdateWithWhereUniqueWithoutTypeOfShiftInput[]
    | HourUpdateWithWhereUniqueWithoutTypeOfShiftInput
  >;
  upsert?: Maybe<
    | HourUpsertWithWhereUniqueWithoutTypeOfShiftInput[]
    | HourUpsertWithWhereUniqueWithoutTypeOfShiftInput
  >;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface HourUpdateWithWhereUniqueWithoutTypeOfShiftInput {
  where: HourWhereUniqueInput;
  data: HourUpdateWithoutTypeOfShiftDataInput;
}

export interface HourUpdateWithoutTypeOfShiftDataInput {
  active?: Maybe<Boolean>;
  day?: Maybe<DayUpdateOneWithoutHoursInput>;
  endHour?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutHoursInput>;
  nbBarber?: Maybe<Int>;
  startHour?: Maybe<DateTimeInput>;
}

export interface HourUpsertWithWhereUniqueWithoutTypeOfShiftInput {
  where: HourWhereUniqueInput;
  update: HourUpdateWithoutTypeOfShiftDataInput;
  create: HourCreateWithoutTypeOfShiftInput;
}

export interface TypeOfShiftUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserUpdateInput {
  active?: Maybe<Boolean>;
  appointment?: Maybe<AppointmentUpdateManyWithoutClientInput>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  department?: Maybe<DepartmentUpdateOneWithoutUserInput>;
  email?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateManyWithoutOwnerInput>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  report?: Maybe<ReportUpdateManyWithoutAuthorInput>;
  review?: Maybe<ReviewUpdateManyWithoutAuthorInput>;
  roles?: Maybe<Json>;
  userEstablishment?: Maybe<UserEstablishmentUpdateManyWithoutManagerInput>;
}

export interface UserUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  birthdate?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  gender?: Maybe<String>;
  lastname?: Maybe<String>;
  password?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  roles?: Maybe<Json>;
}

export interface UserEstablishmentCreateInput {
  id?: Maybe<Int>;
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutUserEstablishmentInput>;
  manager?: Maybe<UserCreateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface UserEstablishmentUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutUserEstablishmentInput>;
  manager?: Maybe<UserUpdateOneWithoutUserEstablishmentInput>;
  validated?: Maybe<Boolean>;
}

export interface UserEstablishmentUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  validated?: Maybe<Boolean>;
}

export interface AppointmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppointmentWhereInput>;
  AND?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
}

export interface AppointmentStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppointmentStatusWhereInput>;
  AND?: Maybe<
    | AppointmentStatusSubscriptionWhereInput[]
    | AppointmentStatusSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AppointmentStatusSubscriptionWhereInput[]
    | AppointmentStatusSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AppointmentStatusSubscriptionWhereInput[]
    | AppointmentStatusSubscriptionWhereInput
  >;
}

export interface DaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DayWhereInput>;
  AND?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
  OR?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
  NOT?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface EstablishmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EstablishmentWhereInput>;
  AND?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
}

export interface HourSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HourWhereInput>;
  AND?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
  OR?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
  NOT?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceWhereInput>;
  AND?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  OR?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  NOT?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
}

export interface TypeOfShiftSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TypeOfShiftWhereInput>;
  AND?: Maybe<
    TypeOfShiftSubscriptionWhereInput[] | TypeOfShiftSubscriptionWhereInput
  >;
  OR?: Maybe<
    TypeOfShiftSubscriptionWhereInput[] | TypeOfShiftSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TypeOfShiftSubscriptionWhereInput[] | TypeOfShiftSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserEstablishmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserEstablishmentWhereInput>;
  AND?: Maybe<
    | UserEstablishmentSubscriptionWhereInput[]
    | UserEstablishmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserEstablishmentSubscriptionWhereInput[]
    | UserEstablishmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserEstablishmentSubscriptionWhereInput[]
    | UserEstablishmentSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Appointment {
  id: Int;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  endHour?: DateTimeOutput;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AppointmentPromise extends Promise<Appointment>, Fragmentable {
  id: () => Promise<Int>;
  appointmentStatus: <T = AppointmentStatusPromise>() => T;
  client: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppointmentSubscription
  extends Promise<AsyncIterator<Appointment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  appointmentStatus: <T = AppointmentStatusSubscription>() => T;
  client: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  establishment: <T = EstablishmentSubscription>() => T;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AppointmentNullablePromise
  extends Promise<Appointment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  appointmentStatus: <T = AppointmentStatusPromise>() => T;
  client: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppointmentStatus {
  id: Int;
  name?: String;
}

export interface AppointmentStatusPromise
  extends Promise<AppointmentStatus>,
    Fragmentable {
  id: () => Promise<Int>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface AppointmentStatusSubscription
  extends Promise<AsyncIterator<AppointmentStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  appointment: <T = Promise<AsyncIterator<AppointmentSubscription>>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AppointmentStatusNullablePromise
  extends Promise<AppointmentStatus | null>,
    Fragmentable {
  id: () => Promise<Int>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface User {
  id: Int;
  active: Boolean;
  birthdate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  email: String;
  firstname?: String;
  gender?: String;
  lastname?: String;
  password: String;
  phoneNumber?: String;
  roles: Json;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  department: <T = DepartmentPromise>() => T;
  email: () => Promise<String>;
  establishment: <T = FragmentableArray<Establishment>>(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
  userEstablishment: <T = FragmentableArray<UserEstablishment>>(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  appointment: <T = Promise<AsyncIterator<AppointmentSubscription>>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  department: <T = DepartmentSubscription>() => T;
  email: () => Promise<AsyncIterator<String>>;
  establishment: <
    T = Promise<AsyncIterator<EstablishmentSubscription>>
  >(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  report: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<AsyncIterator<Json>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userEstablishment: <
    T = Promise<AsyncIterator<UserEstablishmentSubscription>>
  >(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  department: <T = DepartmentPromise>() => T;
  email: () => Promise<String>;
  establishment: <T = FragmentableArray<Establishment>>(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
  userEstablishment: <T = FragmentableArray<UserEstablishment>>(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Department {
  id: Int;
  departmentCode?: Int;
  name?: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  establishment: <T = FragmentableArray<Establishment>>(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  user: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  departmentCode: () => Promise<AsyncIterator<Int>>;
  establishment: <
    T = Promise<AsyncIterator<EstablishmentSubscription>>
  >(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  establishment: <T = FragmentableArray<Establishment>>(args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  user: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Establishment {
  id: Int;
  active: Boolean;
  address?: String;
  addressComplement?: String;
  city?: String;
  commercialName?: String;
  contactEmail?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  description?: String;
  illustration?: String;
  name?: String;
  phoneNumber?: String;
  siret?: String;
  updatedAt: DateTimeOutput;
  zipCode?: String;
}

export interface EstablishmentPromise
  extends Promise<Establishment>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  department: <T = DepartmentPromise>() => T;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  phoneNumber: () => Promise<String>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  userEstablishment: <T = FragmentableArray<UserEstablishment>>(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zipCode: () => Promise<String>;
}

export interface EstablishmentSubscription
  extends Promise<AsyncIterator<Establishment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  address: () => Promise<AsyncIterator<String>>;
  addressComplement: () => Promise<AsyncIterator<String>>;
  appointment: <T = Promise<AsyncIterator<AppointmentSubscription>>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<AsyncIterator<String>>;
  commercialName: () => Promise<AsyncIterator<String>>;
  contactEmail: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  department: <T = DepartmentSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  report: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  siret: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userEstablishment: <
    T = Promise<AsyncIterator<UserEstablishmentSubscription>>
  >(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface EstablishmentNullablePromise
  extends Promise<Establishment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  appointment: <T = FragmentableArray<Appointment>>(args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  department: <T = DepartmentPromise>() => T;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  phoneNumber: () => Promise<String>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  review: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  userEstablishment: <T = FragmentableArray<UserEstablishment>>(args?: {
    where?: UserEstablishmentWhereInput;
    orderBy?: UserEstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zipCode: () => Promise<String>;
}

export interface Hour {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  endHour?: DateTimeOutput;
  nbBarber?: Int;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HourPromise extends Promise<Hour>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  day: <T = DayPromise>() => T;
  endHour: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  typeOfShift: <T = TypeOfShiftPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HourSubscription
  extends Promise<AsyncIterator<Hour>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  day: <T = DaySubscription>() => T;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  establishment: <T = EstablishmentSubscription>() => T;
  nbBarber: () => Promise<AsyncIterator<Int>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  typeOfShift: <T = TypeOfShiftSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HourNullablePromise
  extends Promise<Hour | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  day: <T = DayPromise>() => T;
  endHour: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  typeOfShift: <T = TypeOfShiftPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Day {
  id: Int;
  name: String;
}

export interface DayPromise extends Promise<Day>, Fragmentable {
  id: () => Promise<Int>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface DaySubscription
  extends Promise<AsyncIterator<Day>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DayNullablePromise extends Promise<Day | null>, Fragmentable {
  id: () => Promise<Int>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface TypeOfShift {
  id: Int;
  name?: String;
}

export interface TypeOfShiftPromise extends Promise<TypeOfShift>, Fragmentable {
  id: () => Promise<Int>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface TypeOfShiftSubscription
  extends Promise<AsyncIterator<TypeOfShift>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TypeOfShiftNullablePromise
  extends Promise<TypeOfShift | null>,
    Fragmentable {
  id: () => Promise<Int>;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface Report {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title?: String;
  updatedAt: DateTimeOutput;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<Int>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  author: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  establishment: <T = EstablishmentSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportNullablePromise
  extends Promise<Report | null>,
    Fragmentable {
  id: () => Promise<Int>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Review {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  mark?: Int;
  updatedAt: DateTimeOutput;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<Int>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  author: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  establishment: <T = EstablishmentSubscription>() => T;
  mark: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewNullablePromise
  extends Promise<Review | null>,
    Fragmentable {
  id: () => Promise<Int>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Service {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  duration?: Int;
  illustration?: String;
  name?: String;
  price?: Float;
  updatedAt: DateTimeOutput;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  establishment: <T = EstablishmentPromise>() => T;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedBy: <T = UserPromise>() => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  establishment: <T = EstablishmentSubscription>() => T;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedBy: <T = UserSubscription>() => T;
}

export interface ServiceNullablePromise
  extends Promise<Service | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  establishment: <T = EstablishmentPromise>() => T;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedBy: <T = UserPromise>() => T;
}

export interface UserEstablishment {
  id: Int;
  deletedAt?: DateTimeOutput;
  validated?: Boolean;
}

export interface UserEstablishmentPromise
  extends Promise<UserEstablishment>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  manager: <T = UserPromise>() => T;
  validated: () => Promise<Boolean>;
}

export interface UserEstablishmentSubscription
  extends Promise<AsyncIterator<UserEstablishment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  establishment: <T = EstablishmentSubscription>() => T;
  manager: <T = UserSubscription>() => T;
  validated: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserEstablishmentNullablePromise
  extends Promise<UserEstablishment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  establishment: <T = EstablishmentPromise>() => T;
  manager: <T = UserPromise>() => T;
  validated: () => Promise<Boolean>;
}

export interface AppointmentConnection {
  pageInfo: PageInfo;
  edges: AppointmentEdge[];
}

export interface AppointmentConnectionPromise
  extends Promise<AppointmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppointmentEdge>>() => T;
  aggregate: <T = AggregateAppointmentPromise>() => T;
}

export interface AppointmentConnectionSubscription
  extends Promise<AsyncIterator<AppointmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppointmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppointmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AppointmentEdge {
  node: Appointment;
  cursor: String;
}

export interface AppointmentEdgePromise
  extends Promise<AppointmentEdge>,
    Fragmentable {
  node: <T = AppointmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppointmentEdgeSubscription
  extends Promise<AsyncIterator<AppointmentEdge>>,
    Fragmentable {
  node: <T = AppointmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAppointment {
  count: Int;
}

export interface AggregateAppointmentPromise
  extends Promise<AggregateAppointment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppointmentSubscription
  extends Promise<AsyncIterator<AggregateAppointment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppointmentStatusConnection {
  pageInfo: PageInfo;
  edges: AppointmentStatusEdge[];
}

export interface AppointmentStatusConnectionPromise
  extends Promise<AppointmentStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppointmentStatusEdge>>() => T;
  aggregate: <T = AggregateAppointmentStatusPromise>() => T;
}

export interface AppointmentStatusConnectionSubscription
  extends Promise<AsyncIterator<AppointmentStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppointmentStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppointmentStatusSubscription>() => T;
}

export interface AppointmentStatusEdge {
  node: AppointmentStatus;
  cursor: String;
}

export interface AppointmentStatusEdgePromise
  extends Promise<AppointmentStatusEdge>,
    Fragmentable {
  node: <T = AppointmentStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppointmentStatusEdgeSubscription
  extends Promise<AsyncIterator<AppointmentStatusEdge>>,
    Fragmentable {
  node: <T = AppointmentStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAppointmentStatus {
  count: Int;
}

export interface AggregateAppointmentStatusPromise
  extends Promise<AggregateAppointmentStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppointmentStatusSubscription
  extends Promise<AsyncIterator<AggregateAppointmentStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DayConnection {
  pageInfo: PageInfo;
  edges: DayEdge[];
}

export interface DayConnectionPromise
  extends Promise<DayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DayEdge>>() => T;
  aggregate: <T = AggregateDayPromise>() => T;
}

export interface DayConnectionSubscription
  extends Promise<AsyncIterator<DayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDaySubscription>() => T;
}

export interface DayEdge {
  node: Day;
  cursor: String;
}

export interface DayEdgePromise extends Promise<DayEdge>, Fragmentable {
  node: <T = DayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DayEdgeSubscription
  extends Promise<AsyncIterator<DayEdge>>,
    Fragmentable {
  node: <T = DaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDay {
  count: Int;
}

export interface AggregateDayPromise
  extends Promise<AggregateDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDaySubscription
  extends Promise<AsyncIterator<AggregateDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EstablishmentConnection {
  pageInfo: PageInfo;
  edges: EstablishmentEdge[];
}

export interface EstablishmentConnectionPromise
  extends Promise<EstablishmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EstablishmentEdge>>() => T;
  aggregate: <T = AggregateEstablishmentPromise>() => T;
}

export interface EstablishmentConnectionSubscription
  extends Promise<AsyncIterator<EstablishmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EstablishmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEstablishmentSubscription>() => T;
}

export interface EstablishmentEdge {
  node: Establishment;
  cursor: String;
}

export interface EstablishmentEdgePromise
  extends Promise<EstablishmentEdge>,
    Fragmentable {
  node: <T = EstablishmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EstablishmentEdgeSubscription
  extends Promise<AsyncIterator<EstablishmentEdge>>,
    Fragmentable {
  node: <T = EstablishmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEstablishment {
  count: Int;
}

export interface AggregateEstablishmentPromise
  extends Promise<AggregateEstablishment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEstablishmentSubscription
  extends Promise<AsyncIterator<AggregateEstablishment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HourConnection {
  pageInfo: PageInfo;
  edges: HourEdge[];
}

export interface HourConnectionPromise
  extends Promise<HourConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HourEdge>>() => T;
  aggregate: <T = AggregateHourPromise>() => T;
}

export interface HourConnectionSubscription
  extends Promise<AsyncIterator<HourConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HourEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHourSubscription>() => T;
}

export interface HourEdge {
  node: Hour;
  cursor: String;
}

export interface HourEdgePromise extends Promise<HourEdge>, Fragmentable {
  node: <T = HourPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HourEdgeSubscription
  extends Promise<AsyncIterator<HourEdge>>,
    Fragmentable {
  node: <T = HourSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHour {
  count: Int;
}

export interface AggregateHourPromise
  extends Promise<AggregateHour>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHourSubscription
  extends Promise<AsyncIterator<AggregateHour>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TypeOfShiftConnection {
  pageInfo: PageInfo;
  edges: TypeOfShiftEdge[];
}

export interface TypeOfShiftConnectionPromise
  extends Promise<TypeOfShiftConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TypeOfShiftEdge>>() => T;
  aggregate: <T = AggregateTypeOfShiftPromise>() => T;
}

export interface TypeOfShiftConnectionSubscription
  extends Promise<AsyncIterator<TypeOfShiftConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TypeOfShiftEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTypeOfShiftSubscription>() => T;
}

export interface TypeOfShiftEdge {
  node: TypeOfShift;
  cursor: String;
}

export interface TypeOfShiftEdgePromise
  extends Promise<TypeOfShiftEdge>,
    Fragmentable {
  node: <T = TypeOfShiftPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TypeOfShiftEdgeSubscription
  extends Promise<AsyncIterator<TypeOfShiftEdge>>,
    Fragmentable {
  node: <T = TypeOfShiftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTypeOfShift {
  count: Int;
}

export interface AggregateTypeOfShiftPromise
  extends Promise<AggregateTypeOfShift>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTypeOfShiftSubscription
  extends Promise<AsyncIterator<AggregateTypeOfShift>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEstablishmentConnection {
  pageInfo: PageInfo;
  edges: UserEstablishmentEdge[];
}

export interface UserEstablishmentConnectionPromise
  extends Promise<UserEstablishmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEstablishmentEdge>>() => T;
  aggregate: <T = AggregateUserEstablishmentPromise>() => T;
}

export interface UserEstablishmentConnectionSubscription
  extends Promise<AsyncIterator<UserEstablishmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEstablishmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserEstablishmentSubscription>() => T;
}

export interface UserEstablishmentEdge {
  node: UserEstablishment;
  cursor: String;
}

export interface UserEstablishmentEdgePromise
  extends Promise<UserEstablishmentEdge>,
    Fragmentable {
  node: <T = UserEstablishmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEstablishmentEdgeSubscription
  extends Promise<AsyncIterator<UserEstablishmentEdge>>,
    Fragmentable {
  node: <T = UserEstablishmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserEstablishment {
  count: Int;
}

export interface AggregateUserEstablishmentPromise
  extends Promise<AggregateUserEstablishment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserEstablishmentSubscription
  extends Promise<AsyncIterator<AggregateUserEstablishment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AppointmentSubscriptionPayload {
  mutation: MutationType;
  node: Appointment;
  updatedFields: String[];
  previousValues: AppointmentPreviousValues;
}

export interface AppointmentSubscriptionPayloadPromise
  extends Promise<AppointmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppointmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppointmentPreviousValuesPromise>() => T;
}

export interface AppointmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppointmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppointmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppointmentPreviousValuesSubscription>() => T;
}

export interface AppointmentPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  endHour?: DateTimeOutput;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AppointmentPreviousValuesPromise
  extends Promise<AppointmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppointmentPreviousValuesSubscription
  extends Promise<AsyncIterator<AppointmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AppointmentStatusSubscriptionPayload {
  mutation: MutationType;
  node: AppointmentStatus;
  updatedFields: String[];
  previousValues: AppointmentStatusPreviousValues;
}

export interface AppointmentStatusSubscriptionPayloadPromise
  extends Promise<AppointmentStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppointmentStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppointmentStatusPreviousValuesPromise>() => T;
}

export interface AppointmentStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppointmentStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppointmentStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppointmentStatusPreviousValuesSubscription>() => T;
}

export interface AppointmentStatusPreviousValues {
  id: Int;
  name?: String;
}

export interface AppointmentStatusPreviousValuesPromise
  extends Promise<AppointmentStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface AppointmentStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<AppointmentStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DaySubscriptionPayload {
  mutation: MutationType;
  node: Day;
  updatedFields: String[];
  previousValues: DayPreviousValues;
}

export interface DaySubscriptionPayloadPromise
  extends Promise<DaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DayPreviousValuesPromise>() => T;
}

export interface DaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DayPreviousValuesSubscription>() => T;
}

export interface DayPreviousValues {
  id: Int;
  name: String;
}

export interface DayPreviousValuesPromise
  extends Promise<DayPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface DayPreviousValuesSubscription
  extends Promise<AsyncIterator<DayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: Int;
  departmentCode?: Int;
  name?: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  departmentCode: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  departmentCode: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EstablishmentSubscriptionPayload {
  mutation: MutationType;
  node: Establishment;
  updatedFields: String[];
  previousValues: EstablishmentPreviousValues;
}

export interface EstablishmentSubscriptionPayloadPromise
  extends Promise<EstablishmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EstablishmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EstablishmentPreviousValuesPromise>() => T;
}

export interface EstablishmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EstablishmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EstablishmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EstablishmentPreviousValuesSubscription>() => T;
}

export interface EstablishmentPreviousValues {
  id: Int;
  active: Boolean;
  address?: String;
  addressComplement?: String;
  city?: String;
  commercialName?: String;
  contactEmail?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  description?: String;
  illustration?: String;
  name?: String;
  phoneNumber?: String;
  siret?: String;
  updatedAt: DateTimeOutput;
  zipCode?: String;
}

export interface EstablishmentPreviousValuesPromise
  extends Promise<EstablishmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  address: () => Promise<String>;
  addressComplement: () => Promise<String>;
  city: () => Promise<String>;
  commercialName: () => Promise<String>;
  contactEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  siret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zipCode: () => Promise<String>;
}

export interface EstablishmentPreviousValuesSubscription
  extends Promise<AsyncIterator<EstablishmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  address: () => Promise<AsyncIterator<String>>;
  addressComplement: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  commercialName: () => Promise<AsyncIterator<String>>;
  contactEmail: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  siret: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface HourSubscriptionPayload {
  mutation: MutationType;
  node: Hour;
  updatedFields: String[];
  previousValues: HourPreviousValues;
}

export interface HourSubscriptionPayloadPromise
  extends Promise<HourSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HourPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HourPreviousValuesPromise>() => T;
}

export interface HourSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HourSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HourSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HourPreviousValuesSubscription>() => T;
}

export interface HourPreviousValues {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  endHour?: DateTimeOutput;
  nbBarber?: Int;
  startHour?: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HourPreviousValuesPromise
  extends Promise<HourPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  endHour: () => Promise<DateTimeOutput>;
  nbBarber: () => Promise<Int>;
  startHour: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HourPreviousValuesSubscription
  extends Promise<AsyncIterator<HourPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  nbBarber: () => Promise<AsyncIterator<Int>>;
  startHour: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface ReportPreviousValues {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title?: String;
  updatedAt: DateTimeOutput;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface ReviewPreviousValues {
  id: Int;
  content?: String;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  mark?: Int;
  updatedAt: DateTimeOutput;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  mark: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  mark: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: Int;
  active: Boolean;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  duration?: Int;
  illustration?: String;
  name?: String;
  price?: Float;
  updatedAt: DateTimeOutput;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  illustration: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  illustration: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TypeOfShiftSubscriptionPayload {
  mutation: MutationType;
  node: TypeOfShift;
  updatedFields: String[];
  previousValues: TypeOfShiftPreviousValues;
}

export interface TypeOfShiftSubscriptionPayloadPromise
  extends Promise<TypeOfShiftSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TypeOfShiftPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TypeOfShiftPreviousValuesPromise>() => T;
}

export interface TypeOfShiftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TypeOfShiftSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TypeOfShiftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TypeOfShiftPreviousValuesSubscription>() => T;
}

export interface TypeOfShiftPreviousValues {
  id: Int;
  name?: String;
}

export interface TypeOfShiftPreviousValuesPromise
  extends Promise<TypeOfShiftPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface TypeOfShiftPreviousValuesSubscription
  extends Promise<AsyncIterator<TypeOfShiftPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  active: Boolean;
  birthdate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  email: String;
  firstname?: String;
  gender?: String;
  lastname?: String;
  password: String;
  phoneNumber?: String;
  roles: Json;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  birthdate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  gender: () => Promise<String>;
  lastname: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  roles: () => Promise<Json>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Json>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEstablishmentSubscriptionPayload {
  mutation: MutationType;
  node: UserEstablishment;
  updatedFields: String[];
  previousValues: UserEstablishmentPreviousValues;
}

export interface UserEstablishmentSubscriptionPayloadPromise
  extends Promise<UserEstablishmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserEstablishmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserEstablishmentPreviousValuesPromise>() => T;
}

export interface UserEstablishmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserEstablishmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserEstablishmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserEstablishmentPreviousValuesSubscription>() => T;
}

export interface UserEstablishmentPreviousValues {
  id: Int;
  deletedAt?: DateTimeOutput;
  validated?: Boolean;
}

export interface UserEstablishmentPreviousValuesPromise
  extends Promise<UserEstablishmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  validated: () => Promise<Boolean>;
}

export interface UserEstablishmentPreviousValuesSubscription
  extends Promise<AsyncIterator<UserEstablishmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validated: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Appointment",
    embedded: false
  },
  {
    name: "AppointmentStatus",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Establishment",
    embedded: false
  },
  {
    name: "Hour",
    embedded: false
  },
  {
    name: "Report",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "TypeOfShift",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserEstablishment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
