type Aggregateappointment {
  count: Int!
}

type Aggregateday {
  count: Int!
}

type Aggregatedepartment {
  count: Int!
}

type AggregateEstablishment {
  count: Int!
}

type Aggregatehour {
  count: Int!
}

type Aggregatereport {
  count: Int!
}

type Aggregatereview {
  count: Int!
}

type Aggregateservice {
  count: Int!
}

type Aggregatetypeofshift {
  count: Int!
}

type Aggregateuser {
  count: Int!
}

type Aggregateuserestablishment {
  count: Int!
}

type appointment {
  id: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  endHour: DateTime
  startHour: DateTime
  updatedAt: DateTime!
}

type appointmentConnection {
  pageInfo: PageInfo!
  edges: [appointmentEdge]!
  aggregate: Aggregateappointment!
}

input appointmentCreateInput {
  id: Int
  deletedAt: DateTime
  endHour: DateTime
  startHour: DateTime
}

type appointmentEdge {
  node: appointment!
  cursor: String!
}

enum appointmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  endHour_ASC
  endHour_DESC
  startHour_ASC
  startHour_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type appointmentPreviousValues {
  id: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  endHour: DateTime
  startHour: DateTime
  updatedAt: DateTime!
}

type appointmentSubscriptionPayload {
  mutation: MutationType!
  node: appointment
  updatedFields: [String!]
  previousValues: appointmentPreviousValues
}

input appointmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: appointmentWhereInput
  AND: [appointmentSubscriptionWhereInput!]
  OR: [appointmentSubscriptionWhereInput!]
  NOT: [appointmentSubscriptionWhereInput!]
}

input appointmentUpdateInput {
  deletedAt: DateTime
  endHour: DateTime
  startHour: DateTime
}

input appointmentUpdateManyMutationInput {
  deletedAt: DateTime
  endHour: DateTime
  startHour: DateTime
}

input appointmentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  endHour: DateTime
  endHour_not: DateTime
  endHour_in: [DateTime!]
  endHour_not_in: [DateTime!]
  endHour_lt: DateTime
  endHour_lte: DateTime
  endHour_gt: DateTime
  endHour_gte: DateTime
  startHour: DateTime
  startHour_not: DateTime
  startHour_in: [DateTime!]
  startHour_not_in: [DateTime!]
  startHour_lt: DateTime
  startHour_lte: DateTime
  startHour_gt: DateTime
  startHour_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [appointmentWhereInput!]
  OR: [appointmentWhereInput!]
  NOT: [appointmentWhereInput!]
}

input appointmentWhereUniqueInput {
  id: Int
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type day {
  id: Int!
  name: String!
}

type dayConnection {
  pageInfo: PageInfo!
  edges: [dayEdge]!
  aggregate: Aggregateday!
}

input dayCreateInput {
  id: Int
  name: String!
}

type dayEdge {
  node: day!
  cursor: String!
}

enum dayOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type dayPreviousValues {
  id: Int!
  name: String!
}

type daySubscriptionPayload {
  mutation: MutationType!
  node: day
  updatedFields: [String!]
  previousValues: dayPreviousValues
}

input daySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: dayWhereInput
  AND: [daySubscriptionWhereInput!]
  OR: [daySubscriptionWhereInput!]
  NOT: [daySubscriptionWhereInput!]
}

input dayUpdateInput {
  name: String
}

input dayUpdateManyMutationInput {
  name: String
}

input dayWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [dayWhereInput!]
  OR: [dayWhereInput!]
  NOT: [dayWhereInput!]
}

input dayWhereUniqueInput {
  id: Int
}

type department {
  id: Int!
  departmentCode: Int
  name: String
}

type departmentConnection {
  pageInfo: PageInfo!
  edges: [departmentEdge]!
  aggregate: Aggregatedepartment!
}

input departmentCreateInput {
  id: Int
  departmentCode: Int
  name: String
}

type departmentEdge {
  node: department!
  cursor: String!
}

enum departmentOrderByInput {
  id_ASC
  id_DESC
  departmentCode_ASC
  departmentCode_DESC
  name_ASC
  name_DESC
}

type departmentPreviousValues {
  id: Int!
  departmentCode: Int
  name: String
}

type departmentSubscriptionPayload {
  mutation: MutationType!
  node: department
  updatedFields: [String!]
  previousValues: departmentPreviousValues
}

input departmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: departmentWhereInput
  AND: [departmentSubscriptionWhereInput!]
  OR: [departmentSubscriptionWhereInput!]
  NOT: [departmentSubscriptionWhereInput!]
}

input departmentUpdateInput {
  departmentCode: Int
  name: String
}

input departmentUpdateManyMutationInput {
  departmentCode: Int
  name: String
}

input departmentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  departmentCode: Int
  departmentCode_not: Int
  departmentCode_in: [Int!]
  departmentCode_not_in: [Int!]
  departmentCode_lt: Int
  departmentCode_lte: Int
  departmentCode_gt: Int
  departmentCode_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [departmentWhereInput!]
  OR: [departmentWhereInput!]
  NOT: [departmentWhereInput!]
}

input departmentWhereUniqueInput {
  id: Int
}

type Establishment {
  id: Int!
  active: Boolean!
  address: String
  addressComplement: String
  city: String
  commercialName: String
  contactEmail: String
  createdAt: DateTime!
  deletedAt: DateTime
  description: String
  illustration: String
  name: String
  phoneNumber: String
  siret: String
  updatedAt: DateTime!
  zipCode: String
}

type EstablishmentConnection {
  pageInfo: PageInfo!
  edges: [EstablishmentEdge]!
  aggregate: AggregateEstablishment!
}

input EstablishmentCreateInput {
  id: Int
  active: Boolean
  address: String
  addressComplement: String
  city: String
  commercialName: String
  contactEmail: String
  deletedAt: DateTime
  description: String
  illustration: String
  name: String
  phoneNumber: String
  siret: String
  zipCode: String
}

type EstablishmentEdge {
  node: Establishment!
  cursor: String!
}

enum EstablishmentOrderByInput {
  id_ASC
  id_DESC
  active_ASC
  active_DESC
  address_ASC
  address_DESC
  addressComplement_ASC
  addressComplement_DESC
  city_ASC
  city_DESC
  commercialName_ASC
  commercialName_DESC
  contactEmail_ASC
  contactEmail_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  description_ASC
  description_DESC
  illustration_ASC
  illustration_DESC
  name_ASC
  name_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  siret_ASC
  siret_DESC
  updatedAt_ASC
  updatedAt_DESC
  zipCode_ASC
  zipCode_DESC
}

type EstablishmentPreviousValues {
  id: Int!
  active: Boolean!
  address: String
  addressComplement: String
  city: String
  commercialName: String
  contactEmail: String
  createdAt: DateTime!
  deletedAt: DateTime
  description: String
  illustration: String
  name: String
  phoneNumber: String
  siret: String
  updatedAt: DateTime!
  zipCode: String
}

type EstablishmentSubscriptionPayload {
  mutation: MutationType!
  node: Establishment
  updatedFields: [String!]
  previousValues: EstablishmentPreviousValues
}

input EstablishmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EstablishmentWhereInput
  AND: [EstablishmentSubscriptionWhereInput!]
  OR: [EstablishmentSubscriptionWhereInput!]
  NOT: [EstablishmentSubscriptionWhereInput!]
}

input EstablishmentUpdateInput {
  active: Boolean
  address: String
  addressComplement: String
  city: String
  commercialName: String
  contactEmail: String
  deletedAt: DateTime
  description: String
  illustration: String
  name: String
  phoneNumber: String
  siret: String
  zipCode: String
}

input EstablishmentUpdateManyMutationInput {
  active: Boolean
  address: String
  addressComplement: String
  city: String
  commercialName: String
  contactEmail: String
  deletedAt: DateTime
  description: String
  illustration: String
  name: String
  phoneNumber: String
  siret: String
  zipCode: String
}

input EstablishmentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  active: Boolean
  active_not: Boolean
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  addressComplement: String
  addressComplement_not: String
  addressComplement_in: [String!]
  addressComplement_not_in: [String!]
  addressComplement_lt: String
  addressComplement_lte: String
  addressComplement_gt: String
  addressComplement_gte: String
  addressComplement_contains: String
  addressComplement_not_contains: String
  addressComplement_starts_with: String
  addressComplement_not_starts_with: String
  addressComplement_ends_with: String
  addressComplement_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  commercialName: String
  commercialName_not: String
  commercialName_in: [String!]
  commercialName_not_in: [String!]
  commercialName_lt: String
  commercialName_lte: String
  commercialName_gt: String
  commercialName_gte: String
  commercialName_contains: String
  commercialName_not_contains: String
  commercialName_starts_with: String
  commercialName_not_starts_with: String
  commercialName_ends_with: String
  commercialName_not_ends_with: String
  contactEmail: String
  contactEmail_not: String
  contactEmail_in: [String!]
  contactEmail_not_in: [String!]
  contactEmail_lt: String
  contactEmail_lte: String
  contactEmail_gt: String
  contactEmail_gte: String
  contactEmail_contains: String
  contactEmail_not_contains: String
  contactEmail_starts_with: String
  contactEmail_not_starts_with: String
  contactEmail_ends_with: String
  contactEmail_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  illustration: String
  illustration_not: String
  illustration_in: [String!]
  illustration_not_in: [String!]
  illustration_lt: String
  illustration_lte: String
  illustration_gt: String
  illustration_gte: String
  illustration_contains: String
  illustration_not_contains: String
  illustration_starts_with: String
  illustration_not_starts_with: String
  illustration_ends_with: String
  illustration_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  siret: String
  siret_not: String
  siret_in: [String!]
  siret_not_in: [String!]
  siret_lt: String
  siret_lte: String
  siret_gt: String
  siret_gte: String
  siret_contains: String
  siret_not_contains: String
  siret_starts_with: String
  siret_not_starts_with: String
  siret_ends_with: String
  siret_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  AND: [EstablishmentWhereInput!]
  OR: [EstablishmentWhereInput!]
  NOT: [EstablishmentWhereInput!]
}

input EstablishmentWhereUniqueInput {
  id: Int
}

type hour {
  id: Int!
  active: Boolean!
  createdAt: DateTime!
  endHour: DateTime
  nbBarber: Int
  startHour: DateTime
  updatedAt: DateTime!
}

type hourConnection {
  pageInfo: PageInfo!
  edges: [hourEdge]!
  aggregate: Aggregatehour!
}

input hourCreateInput {
  id: Int
  active: Boolean
  endHour: DateTime
  nbBarber: Int
  startHour: DateTime
}

type hourEdge {
  node: hour!
  cursor: String!
}

enum hourOrderByInput {
  id_ASC
  id_DESC
  active_ASC
  active_DESC
  createdAt_ASC
  createdAt_DESC
  endHour_ASC
  endHour_DESC
  nbBarber_ASC
  nbBarber_DESC
  startHour_ASC
  startHour_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type hourPreviousValues {
  id: Int!
  active: Boolean!
  createdAt: DateTime!
  endHour: DateTime
  nbBarber: Int
  startHour: DateTime
  updatedAt: DateTime!
}

type hourSubscriptionPayload {
  mutation: MutationType!
  node: hour
  updatedFields: [String!]
  previousValues: hourPreviousValues
}

input hourSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: hourWhereInput
  AND: [hourSubscriptionWhereInput!]
  OR: [hourSubscriptionWhereInput!]
  NOT: [hourSubscriptionWhereInput!]
}

input hourUpdateInput {
  active: Boolean
  endHour: DateTime
  nbBarber: Int
  startHour: DateTime
}

input hourUpdateManyMutationInput {
  active: Boolean
  endHour: DateTime
  nbBarber: Int
  startHour: DateTime
}

input hourWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  active: Boolean
  active_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  endHour: DateTime
  endHour_not: DateTime
  endHour_in: [DateTime!]
  endHour_not_in: [DateTime!]
  endHour_lt: DateTime
  endHour_lte: DateTime
  endHour_gt: DateTime
  endHour_gte: DateTime
  nbBarber: Int
  nbBarber_not: Int
  nbBarber_in: [Int!]
  nbBarber_not_in: [Int!]
  nbBarber_lt: Int
  nbBarber_lte: Int
  nbBarber_gt: Int
  nbBarber_gte: Int
  startHour: DateTime
  startHour_not: DateTime
  startHour_in: [DateTime!]
  startHour_not_in: [DateTime!]
  startHour_lt: DateTime
  startHour_lte: DateTime
  startHour_gt: DateTime
  startHour_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [hourWhereInput!]
  OR: [hourWhereInput!]
  NOT: [hourWhereInput!]
}

input hourWhereUniqueInput {
  id: Int
}

scalar Json

scalar Long

type Mutation {
  createEstablishment(data: EstablishmentCreateInput!): Establishment!
  updateEstablishment(data: EstablishmentUpdateInput!, where: EstablishmentWhereUniqueInput!): Establishment
  updateManyEstablishments(data: EstablishmentUpdateManyMutationInput!, where: EstablishmentWhereInput): BatchPayload!
  upsertEstablishment(where: EstablishmentWhereUniqueInput!, create: EstablishmentCreateInput!, update: EstablishmentUpdateInput!): Establishment!
  deleteEstablishment(where: EstablishmentWhereUniqueInput!): Establishment
  deleteManyEstablishments(where: EstablishmentWhereInput): BatchPayload!
  createappointment(data: appointmentCreateInput!): appointment!
  updateappointment(data: appointmentUpdateInput!, where: appointmentWhereUniqueInput!): appointment
  updateManyappointments(data: appointmentUpdateManyMutationInput!, where: appointmentWhereInput): BatchPayload!
  upsertappointment(where: appointmentWhereUniqueInput!, create: appointmentCreateInput!, update: appointmentUpdateInput!): appointment!
  deleteappointment(where: appointmentWhereUniqueInput!): appointment
  deleteManyappointments(where: appointmentWhereInput): BatchPayload!
  createday(data: dayCreateInput!): day!
  updateday(data: dayUpdateInput!, where: dayWhereUniqueInput!): day
  updateManydays(data: dayUpdateManyMutationInput!, where: dayWhereInput): BatchPayload!
  upsertday(where: dayWhereUniqueInput!, create: dayCreateInput!, update: dayUpdateInput!): day!
  deleteday(where: dayWhereUniqueInput!): day
  deleteManydays(where: dayWhereInput): BatchPayload!
  createdepartment(data: departmentCreateInput!): department!
  updatedepartment(data: departmentUpdateInput!, where: departmentWhereUniqueInput!): department
  updateManydepartments(data: departmentUpdateManyMutationInput!, where: departmentWhereInput): BatchPayload!
  upsertdepartment(where: departmentWhereUniqueInput!, create: departmentCreateInput!, update: departmentUpdateInput!): department!
  deletedepartment(where: departmentWhereUniqueInput!): department
  deleteManydepartments(where: departmentWhereInput): BatchPayload!
  createhour(data: hourCreateInput!): hour!
  updatehour(data: hourUpdateInput!, where: hourWhereUniqueInput!): hour
  updateManyhours(data: hourUpdateManyMutationInput!, where: hourWhereInput): BatchPayload!
  upserthour(where: hourWhereUniqueInput!, create: hourCreateInput!, update: hourUpdateInput!): hour!
  deletehour(where: hourWhereUniqueInput!): hour
  deleteManyhours(where: hourWhereInput): BatchPayload!
  createreport(data: reportCreateInput!): report!
  updatereport(data: reportUpdateInput!, where: reportWhereUniqueInput!): report
  updateManyreports(data: reportUpdateManyMutationInput!, where: reportWhereInput): BatchPayload!
  upsertreport(where: reportWhereUniqueInput!, create: reportCreateInput!, update: reportUpdateInput!): report!
  deletereport(where: reportWhereUniqueInput!): report
  deleteManyreports(where: reportWhereInput): BatchPayload!
  createreview(data: reviewCreateInput!): review!
  updatereview(data: reviewUpdateInput!, where: reviewWhereUniqueInput!): review
  updateManyreviews(data: reviewUpdateManyMutationInput!, where: reviewWhereInput): BatchPayload!
  upsertreview(where: reviewWhereUniqueInput!, create: reviewCreateInput!, update: reviewUpdateInput!): review!
  deletereview(where: reviewWhereUniqueInput!): review
  deleteManyreviews(where: reviewWhereInput): BatchPayload!
  createservice(data: serviceCreateInput!): service!
  updateservice(data: serviceUpdateInput!, where: serviceWhereUniqueInput!): service
  updateManyservices(data: serviceUpdateManyMutationInput!, where: serviceWhereInput): BatchPayload!
  upsertservice(where: serviceWhereUniqueInput!, create: serviceCreateInput!, update: serviceUpdateInput!): service!
  deleteservice(where: serviceWhereUniqueInput!): service
  deleteManyservices(where: serviceWhereInput): BatchPayload!
  createtypeofshift(data: typeofshiftCreateInput!): typeofshift!
  updatetypeofshift(data: typeofshiftUpdateInput!, where: typeofshiftWhereUniqueInput!): typeofshift
  updateManytypeofshifts(data: typeofshiftUpdateManyMutationInput!, where: typeofshiftWhereInput): BatchPayload!
  upserttypeofshift(where: typeofshiftWhereUniqueInput!, create: typeofshiftCreateInput!, update: typeofshiftUpdateInput!): typeofshift!
  deletetypeofshift(where: typeofshiftWhereUniqueInput!): typeofshift
  deleteManytypeofshifts(where: typeofshiftWhereInput): BatchPayload!
  createuser(data: userCreateInput!): user!
  updateuser(data: userUpdateInput!, where: userWhereUniqueInput!): user
  updateManyusers(data: userUpdateManyMutationInput!, where: userWhereInput): BatchPayload!
  upsertuser(where: userWhereUniqueInput!, create: userCreateInput!, update: userUpdateInput!): user!
  deleteuser(where: userWhereUniqueInput!): user
  deleteManyusers(where: userWhereInput): BatchPayload!
  createuserestablishment(data: userestablishmentCreateInput!): userestablishment!
  updateuserestablishment(data: userestablishmentUpdateInput!, where: userestablishmentWhereUniqueInput!): userestablishment
  updateManyuserestablishments(data: userestablishmentUpdateManyMutationInput!, where: userestablishmentWhereInput): BatchPayload!
  upsertuserestablishment(where: userestablishmentWhereUniqueInput!, create: userestablishmentCreateInput!, update: userestablishmentUpdateInput!): userestablishment!
  deleteuserestablishment(where: userestablishmentWhereUniqueInput!): userestablishment
  deleteManyuserestablishments(where: userestablishmentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  establishment(where: EstablishmentWhereUniqueInput!): Establishment
  establishments(where: EstablishmentWhereInput, orderBy: EstablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Establishment]!
  establishmentsConnection(where: EstablishmentWhereInput, orderBy: EstablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EstablishmentConnection!
  appointment(where: appointmentWhereUniqueInput!): appointment
  appointments(where: appointmentWhereInput, orderBy: appointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [appointment]!
  appointmentsConnection(where: appointmentWhereInput, orderBy: appointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): appointmentConnection!
  day(where: dayWhereUniqueInput!): day
  days(where: dayWhereInput, orderBy: dayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [day]!
  daysConnection(where: dayWhereInput, orderBy: dayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): dayConnection!
  department(where: departmentWhereUniqueInput!): department
  departments(where: departmentWhereInput, orderBy: departmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [department]!
  departmentsConnection(where: departmentWhereInput, orderBy: departmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): departmentConnection!
  hour(where: hourWhereUniqueInput!): hour
  hours(where: hourWhereInput, orderBy: hourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [hour]!
  hoursConnection(where: hourWhereInput, orderBy: hourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): hourConnection!
  report(where: reportWhereUniqueInput!): report
  reports(where: reportWhereInput, orderBy: reportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [report]!
  reportsConnection(where: reportWhereInput, orderBy: reportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): reportConnection!
  review(where: reviewWhereUniqueInput!): review
  reviews(where: reviewWhereInput, orderBy: reviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [review]!
  reviewsConnection(where: reviewWhereInput, orderBy: reviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): reviewConnection!
  service(where: serviceWhereUniqueInput!): service
  services(where: serviceWhereInput, orderBy: serviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [service]!
  servicesConnection(where: serviceWhereInput, orderBy: serviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): serviceConnection!
  typeofshift(where: typeofshiftWhereUniqueInput!): typeofshift
  typeofshifts(where: typeofshiftWhereInput, orderBy: typeofshiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [typeofshift]!
  typeofshiftsConnection(where: typeofshiftWhereInput, orderBy: typeofshiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): typeofshiftConnection!
  user(where: userWhereUniqueInput!): user
  users(where: userWhereInput, orderBy: userOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [user]!
  usersConnection(where: userWhereInput, orderBy: userOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): userConnection!
  userestablishment(where: userestablishmentWhereUniqueInput!): userestablishment
  userestablishments(where: userestablishmentWhereInput, orderBy: userestablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [userestablishment]!
  userestablishmentsConnection(where: userestablishmentWhereInput, orderBy: userestablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): userestablishmentConnection!
  node(id: ID!): Node
}

type report {
  id: Int!
  content: String
  createdAt: DateTime!
  deletedAt: DateTime
  title: String
  updatedAt: DateTime!
}

type reportConnection {
  pageInfo: PageInfo!
  edges: [reportEdge]!
  aggregate: Aggregatereport!
}

input reportCreateInput {
  id: Int
  content: String
  deletedAt: DateTime
  title: String
}

type reportEdge {
  node: report!
  cursor: String!
}

enum reportOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type reportPreviousValues {
  id: Int!
  content: String
  createdAt: DateTime!
  deletedAt: DateTime
  title: String
  updatedAt: DateTime!
}

type reportSubscriptionPayload {
  mutation: MutationType!
  node: report
  updatedFields: [String!]
  previousValues: reportPreviousValues
}

input reportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: reportWhereInput
  AND: [reportSubscriptionWhereInput!]
  OR: [reportSubscriptionWhereInput!]
  NOT: [reportSubscriptionWhereInput!]
}

input reportUpdateInput {
  content: String
  deletedAt: DateTime
  title: String
}

input reportUpdateManyMutationInput {
  content: String
  deletedAt: DateTime
  title: String
}

input reportWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [reportWhereInput!]
  OR: [reportWhereInput!]
  NOT: [reportWhereInput!]
}

input reportWhereUniqueInput {
  id: Int
}

type review {
  id: Int!
  content: String
  createdAt: DateTime!
  deletedAt: DateTime
  mark: Int
  updatedAt: DateTime!
}

type reviewConnection {
  pageInfo: PageInfo!
  edges: [reviewEdge]!
  aggregate: Aggregatereview!
}

input reviewCreateInput {
  id: Int
  content: String
  deletedAt: DateTime
  mark: Int
}

type reviewEdge {
  node: review!
  cursor: String!
}

enum reviewOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  mark_ASC
  mark_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type reviewPreviousValues {
  id: Int!
  content: String
  createdAt: DateTime!
  deletedAt: DateTime
  mark: Int
  updatedAt: DateTime!
}

type reviewSubscriptionPayload {
  mutation: MutationType!
  node: review
  updatedFields: [String!]
  previousValues: reviewPreviousValues
}

input reviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: reviewWhereInput
  AND: [reviewSubscriptionWhereInput!]
  OR: [reviewSubscriptionWhereInput!]
  NOT: [reviewSubscriptionWhereInput!]
}

input reviewUpdateInput {
  content: String
  deletedAt: DateTime
  mark: Int
}

input reviewUpdateManyMutationInput {
  content: String
  deletedAt: DateTime
  mark: Int
}

input reviewWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  mark: Int
  mark_not: Int
  mark_in: [Int!]
  mark_not_in: [Int!]
  mark_lt: Int
  mark_lte: Int
  mark_gt: Int
  mark_gte: Int
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [reviewWhereInput!]
  OR: [reviewWhereInput!]
  NOT: [reviewWhereInput!]
}

input reviewWhereUniqueInput {
  id: Int
}

type service {
  id: Int!
  active: Boolean!
  createdAt: DateTime!
  deletedAt: DateTime
  duration: Int
  illustration: String
  name: String
  price: Float
  updatedAt: DateTime!
}

type serviceConnection {
  pageInfo: PageInfo!
  edges: [serviceEdge]!
  aggregate: Aggregateservice!
}

input serviceCreateInput {
  id: Int
  active: Boolean
  deletedAt: DateTime
  duration: Int
  illustration: String
  name: String
  price: Float
}

type serviceEdge {
  node: service!
  cursor: String!
}

enum serviceOrderByInput {
  id_ASC
  id_DESC
  active_ASC
  active_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  duration_ASC
  duration_DESC
  illustration_ASC
  illustration_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type servicePreviousValues {
  id: Int!
  active: Boolean!
  createdAt: DateTime!
  deletedAt: DateTime
  duration: Int
  illustration: String
  name: String
  price: Float
  updatedAt: DateTime!
}

type serviceSubscriptionPayload {
  mutation: MutationType!
  node: service
  updatedFields: [String!]
  previousValues: servicePreviousValues
}

input serviceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: serviceWhereInput
  AND: [serviceSubscriptionWhereInput!]
  OR: [serviceSubscriptionWhereInput!]
  NOT: [serviceSubscriptionWhereInput!]
}

input serviceUpdateInput {
  active: Boolean
  deletedAt: DateTime
  duration: Int
  illustration: String
  name: String
  price: Float
}

input serviceUpdateManyMutationInput {
  active: Boolean
  deletedAt: DateTime
  duration: Int
  illustration: String
  name: String
  price: Float
}

input serviceWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  active: Boolean
  active_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  illustration: String
  illustration_not: String
  illustration_in: [String!]
  illustration_not_in: [String!]
  illustration_lt: String
  illustration_lte: String
  illustration_gt: String
  illustration_gte: String
  illustration_contains: String
  illustration_not_contains: String
  illustration_starts_with: String
  illustration_not_starts_with: String
  illustration_ends_with: String
  illustration_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [serviceWhereInput!]
  OR: [serviceWhereInput!]
  NOT: [serviceWhereInput!]
}

input serviceWhereUniqueInput {
  id: Int
}

type Subscription {
  establishment(where: EstablishmentSubscriptionWhereInput): EstablishmentSubscriptionPayload
  appointment(where: appointmentSubscriptionWhereInput): appointmentSubscriptionPayload
  day(where: daySubscriptionWhereInput): daySubscriptionPayload
  department(where: departmentSubscriptionWhereInput): departmentSubscriptionPayload
  hour(where: hourSubscriptionWhereInput): hourSubscriptionPayload
  report(where: reportSubscriptionWhereInput): reportSubscriptionPayload
  review(where: reviewSubscriptionWhereInput): reviewSubscriptionPayload
  service(where: serviceSubscriptionWhereInput): serviceSubscriptionPayload
  typeofshift(where: typeofshiftSubscriptionWhereInput): typeofshiftSubscriptionPayload
  user(where: userSubscriptionWhereInput): userSubscriptionPayload
  userestablishment(where: userestablishmentSubscriptionWhereInput): userestablishmentSubscriptionPayload
}

type typeofshift {
  id: Int!
  name: String
}

type typeofshiftConnection {
  pageInfo: PageInfo!
  edges: [typeofshiftEdge]!
  aggregate: Aggregatetypeofshift!
}

input typeofshiftCreateInput {
  id: Int
  name: String
}

type typeofshiftEdge {
  node: typeofshift!
  cursor: String!
}

enum typeofshiftOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type typeofshiftPreviousValues {
  id: Int!
  name: String
}

type typeofshiftSubscriptionPayload {
  mutation: MutationType!
  node: typeofshift
  updatedFields: [String!]
  previousValues: typeofshiftPreviousValues
}

input typeofshiftSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: typeofshiftWhereInput
  AND: [typeofshiftSubscriptionWhereInput!]
  OR: [typeofshiftSubscriptionWhereInput!]
  NOT: [typeofshiftSubscriptionWhereInput!]
}

input typeofshiftUpdateInput {
  name: String
}

input typeofshiftUpdateManyMutationInput {
  name: String
}

input typeofshiftWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [typeofshiftWhereInput!]
  OR: [typeofshiftWhereInput!]
  NOT: [typeofshiftWhereInput!]
}

input typeofshiftWhereUniqueInput {
  id: Int
}

type user {
  id: Int!
  active: Boolean!
  birthdate: DateTime
  createdAt: DateTime!
  deletedAt: DateTime
  email: String!
  firstname: String
  gender: String
  lastname: String
  password: String!
  phoneNumber: String
  roles: Json!
  updatedAt: DateTime!
}

type userConnection {
  pageInfo: PageInfo!
  edges: [userEdge]!
  aggregate: Aggregateuser!
}

input userCreateInput {
  id: Int
  active: Boolean
  birthdate: DateTime
  deletedAt: DateTime
  email: String!
  firstname: String
  gender: String
  lastname: String
  password: String!
  phoneNumber: String
  roles: Json!
}

type userEdge {
  node: user!
  cursor: String!
}

type userestablishment {
  id: Int!
  deletedAt: DateTime
  validated: Boolean
}

type userestablishmentConnection {
  pageInfo: PageInfo!
  edges: [userestablishmentEdge]!
  aggregate: Aggregateuserestablishment!
}

input userestablishmentCreateInput {
  id: Int
  deletedAt: DateTime
  validated: Boolean
}

type userestablishmentEdge {
  node: userestablishment!
  cursor: String!
}

enum userestablishmentOrderByInput {
  id_ASC
  id_DESC
  deletedAt_ASC
  deletedAt_DESC
  validated_ASC
  validated_DESC
}

type userestablishmentPreviousValues {
  id: Int!
  deletedAt: DateTime
  validated: Boolean
}

type userestablishmentSubscriptionPayload {
  mutation: MutationType!
  node: userestablishment
  updatedFields: [String!]
  previousValues: userestablishmentPreviousValues
}

input userestablishmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: userestablishmentWhereInput
  AND: [userestablishmentSubscriptionWhereInput!]
  OR: [userestablishmentSubscriptionWhereInput!]
  NOT: [userestablishmentSubscriptionWhereInput!]
}

input userestablishmentUpdateInput {
  deletedAt: DateTime
  validated: Boolean
}

input userestablishmentUpdateManyMutationInput {
  deletedAt: DateTime
  validated: Boolean
}

input userestablishmentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  validated: Boolean
  validated_not: Boolean
  AND: [userestablishmentWhereInput!]
  OR: [userestablishmentWhereInput!]
  NOT: [userestablishmentWhereInput!]
}

input userestablishmentWhereUniqueInput {
  id: Int
}

enum userOrderByInput {
  id_ASC
  id_DESC
  active_ASC
  active_DESC
  birthdate_ASC
  birthdate_DESC
  createdAt_ASC
  createdAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  email_ASC
  email_DESC
  firstname_ASC
  firstname_DESC
  gender_ASC
  gender_DESC
  lastname_ASC
  lastname_DESC
  password_ASC
  password_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  roles_ASC
  roles_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type userPreviousValues {
  id: Int!
  active: Boolean!
  birthdate: DateTime
  createdAt: DateTime!
  deletedAt: DateTime
  email: String!
  firstname: String
  gender: String
  lastname: String
  password: String!
  phoneNumber: String
  roles: Json!
  updatedAt: DateTime!
}

type userSubscriptionPayload {
  mutation: MutationType!
  node: user
  updatedFields: [String!]
  previousValues: userPreviousValues
}

input userSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: userWhereInput
  AND: [userSubscriptionWhereInput!]
  OR: [userSubscriptionWhereInput!]
  NOT: [userSubscriptionWhereInput!]
}

input userUpdateInput {
  active: Boolean
  birthdate: DateTime
  deletedAt: DateTime
  email: String
  firstname: String
  gender: String
  lastname: String
  password: String
  phoneNumber: String
  roles: Json
}

input userUpdateManyMutationInput {
  active: Boolean
  birthdate: DateTime
  deletedAt: DateTime
  email: String
  firstname: String
  gender: String
  lastname: String
  password: String
  phoneNumber: String
  roles: Json
}

input userWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  active: Boolean
  active_not: Boolean
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [userWhereInput!]
  OR: [userWhereInput!]
  NOT: [userWhereInput!]
}

input userWhereUniqueInput {
  id: Int
  email: String
}
